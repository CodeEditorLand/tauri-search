[{"id":"prose_docs_architecture_md","title":"The Tauri Architecture","headings":["Introduction","What Tauri is NOT","Major Components","External Crates","Additional tooling","Tauri Plugins ","Workflows","License"],"subHeadings":["Tauri Core ","Tauri Tooling",[{"content":"TAO","type":"text"}],[{"content":"WRY","type":"text"}],[{"content":"tauri","type":"text"},{"content":"-hotkey","type":"text"},{"content":"-rs","type":"text"}],[{"content":"binary","type":"text"},{"content":"-releases","type":"text"}],[{"content":"tauri","type":"text"},{"content":"-action","type":"text"}],[{"content":"create","type":"text"},{"content":"-pull","type":"text"},{"content":"-request","type":"text"}],[{"content":"vue","type":"text"},{"content":"-cli","type":"text"},{"content":"-plugin","type":"text"},{"content":"-tauri","type":"text"}],[{"content":"tauri","type":"text"},{"content":"-vscode","type":"text"}],"What does the Development flow look like","What does the Release flow look like","What does the End","What does the Updating flow look like"],"code":[null],"text":"# The Tauri Architecture ## Introduction Tauri is a polyglot and generic toolkit\nthat is very composable and allows engineers to make a wide variety of\napplications. It is used for building applications for Desktop Computers using a\ncombination of Rust tools and HTML rendered in a Webview. Apps built with Tauri\ncan ship with any number of pieces of an optional JS API / Rust API so that\nwebviews can control the system via message passing. In fact, developers can\nextend the default API with their own functionality and bridge the Webview and\nRust-based backend easily. Tauri apps can have custom menus and have tray-type\ninterfaces. They can be updated, and are managed by the user's operating system\nas expected. They are very small, because they use the OS's webview. They do not\nship a runtime, since the final binary is compiled from Rust. This makes the\nreversing of Tauri apps not a trivial task. ## What Tauri is NOT - Tauri is not\na lightweight kernel wrapper...instead it directly uses [WRY](#wry) and\n[TAO](#tao) to do the heavy-lifting in making system calls to the OS. - Tauri is\nnot a VM or virtualized environment...instead it is an application toolkit that\nallows making Webview OS applications. ## Major Components The following section\nbriefly describes the roles of the various parts of Tauri. ### Tauri Core\n[STABLE RUST] ####\n[tauri](https://github.com/tauri-apps/tauri/tree/dev/core/tauri) This is the\nmajor crate that holds everything together. It brings the runtimes, macros,\nutilities and API into one final product. It reads the `tauri.conf.json` file at\ncompile time in order to bring in features and undertake actual configuration of\nthe app (and even the `Cargo.toml` file in the project's folder). It handles\nscript injection (for polyfills / prototype revision) at runtime, hosts the API\nfor systems interaction, and even manages updating. ####\n[tauri-build](https://github.com/tauri-apps/tauri/tree/dev/core/tauri-build)\nApply the macros at build-time in order to rig some special features needed by\n`cargo`. ####\n[tauri-codegen](https://github.com/tauri-apps/tauri/tree/dev/core/tauri-codegen)\n- Embed, hash, and compress assets, including icons for the app as well as the\nsystem-tray. - Parse `tauri.conf.json` at compile time and generate the Config\nstruct. ####\n[tauri-macros](https://github.com/tauri-apps/tauri/tree/dev/core/tauri-macros)\nCreate macros for the context, handler, and commands by leveraging the\n`tauri-codegen` crate. ####\n[tauri-runtime](https://github.com/tauri-apps/tauri/tree/dev/core/tauri-runtime)\nThis is the glue layer between tauri itself and lower level webview libraries.\n####\n[tauri-runtime-wry](https://github.com/tauri-apps/tauri/tree/dev/core/tauri-runtime-wry)\nThis crate opens up direct systems-level interactions specifically for WRY, such\nas printing, monitor detection, and other windowing related tasks.\n`tauri-runtime` implementation for WRY. ####\n[tauri-utils](https://github.com/tauri-apps/tauri/tree/dev/core/tauri-utils)\nThis is common code that is reused in many places and offers useful utilities\nlike parsing configuration files, detecting platform triples, injecting the CSP,\nand managing assets. ### Tauri Tooling ####\n[api](https://github.com/tauri-apps/tauri/tree/dev/tooling/api) [TS -> JS] A\ntypescript library that creates `cjs` and `esm` Javascript endpoints for you to\nimport into your Frontend framework so that the Webview can call and listen to\nbackend activity. We also ship the pure typescript, because for some frameworks\nthis is more optimal. It uses the message passing of webviews to their hosts.\n#### [bundler](https://github.com/tauri-apps/tauri/tree/dev/tooling/bundler)\n[RUST / SHELL] The bundler is a library that builds a Tauri App for the platform\ntriple it detects / is told. At the moment it currently supports macOS, Windows\nand Linux - but in the near future will support mobile platforms as well. May be\nused outside of Tauri projects. ####\n[cli.js](https://github.com/tauri-apps/tauri/tree/dev/tooling/cli.js) [JS]\nWritten in Typescript and packaged such that it can be used with `npm`, `pnpm`,\nand `yarn`, this library provides a node.js runner for common tasks when using\nTauri, like `yarn tauri dev`. For the most part it is a wrapper around\n[cli.rs](https://github.com/tauri-apps/tauri/blob/dev/tooling/cli). ####\n[cli.rs](https://github.com/tauri-apps/tauri/tree/dev/tooling/cli) [RUST] This\nrust executable provides the full interface to all of the required activities\nfor which the CLI is required. It will run on macOS, Windows, and Linux. ####\n[create-tauri-app](https://github.com/tauri-apps/tauri/tree/dev/tooling/create-tauri-app)\n[JS] This is a toolkit that will enable engineering teams to rapidly scaffold\nout a new tauri-apps project using the frontend framework of their choice (as\nlong as it has been configured). ## External Crates The Tauri-Apps organisation\nmaintains two \"upstream\" crates from Tauri, namely TAO for creating and managing\napplication windows, and WRY for interfacing with the Webview that lives within\nthe window. ### [TAO](https://github.com/tauri-apps/tao) Cross-platform\napplication window creation library in Rust that supports all major platforms\nlike Windows, macOS, Linux, iOS and Android. Written in Rust, it is a fork of\n[winit](https://github.com/rust-windowing/winit) that we have extended for our\nown needs like menu bar and system tray. ###\n[WRY](https://github.com/tauri-apps/wry) WRY is a cross-platform WebView\nrendering library in Rust that supports all major desktop platforms like\nWindows, macOS, and Linux. Tauri uses WRY as the abstract layer responsible to\ndetermine which webview is used (and how interactions are made). ###\n[tauri-hotkey-rs](https://github.com/tauri-apps/tauri-hotkey-rs) We needed to\nfix hotkey to work on all platforms, because upstream was not being responsive.\n## Additional tooling ###\n[binary-releases](https://github.com/tauri-apps/binary-releases) This is the\ndelivery mechanism for tauri prebuilt binaries: currently the cli.rs (used by\ncli.js) and rustup binaries (used by the deps install command of cli.js). These\nartifacts are automatically created on release. ###\n[tauri-action](https://github.com/tauri-apps/tauri-action) This is a github\nworkflow that builds tauri binaries for all platforms. It is not the fastest out\nthere, but it gets the job done and is highly configurable. Even allowing you to\ncreate a (very basic) tauri app even if tauri is not setup. ###\n[create-pull-request](https://github.com/tauri-apps/create-pull-request) Because\nthis is a very risky (potentially destructive) github action, we forked it in\norder to have strong guarantees that the code we think is running is actually\nthe code that is running. ###\n[vue-cli-plugin-tauri](https://github.com/tauri-apps/vue-cli-plugin-tauri) This\nplugin allows you to very quickly install tauri in a vue-cli project. ###\n[tauri-vscode](https://github.com/tauri-apps/tauri-vscode) This project enhances\nthe VS Code interface with several nice-to-have features. ## Tauri Plugins\n[documentation](https://tauri.studio/en/docs/guides/plugin) Generally speaking,\nplugins are authored by third parties (even though there may be official,\nsupported plugins). A plugin generally does 3 things: 1. It provides rust code\nto do \"something\". 2. It provides interface glue to make it easy to integrate\ninto an app. 3. It provides a JS API for interfacing with the rust code. Here\nare several examples of Tauri Plugins: -\nhttps://github.com/tauri-apps/tauri-plugin-sql -\nhttps://github.com/tauri-apps/tauri-plugin-stronghold -\nhttps://github.com/tauri-apps/tauri-plugin-authenticator ## Workflows ### What\ndoes the Development flow look like? A developer must first install the\nprerequisite toolchains for creating a Tauri app. At the very least this will\nentail installing rust & cargo, and most likely also a modern version of node.js\nand potentially another package manager. Some platforms may also require other\ntooling and libraries, but this has been documented carefully in the respective\nplatform docs. Because of the many ways to build front-ends, we will stick with\na common node.js based approach for development. (Note: Tauri does not by\ndefault ship a node.js runtime.) The easiest way to do this is to run the\nfollowing: ``` npx create-tauri-app ``` Which will ask you a bunch of questions\nabout the framework you want to install and then create everything you need in a\nsingle folder - some via the placement of template files and some through normal\ninstallation procedures of your framework. > If you don't use this process, you\nwill have to manually install the tauri cli, initialise tauri and manually\nconfigure the `tauri.conf.json` file. Once everything is installed, you can run:\n``` yarn tauri dev -or- npm run tauri dev ``` This will do several things: 1.\nstart the JS Framework devserver 2. begin the long process of downloading and\ncompiling the rust libraries 3. open an application window with devtools enabled\n4. keep a long-lived console alive If you change your HTML/CSS/TS/JS, your\nframework devserver should give you its best shot at instant hot module\nreloading and you will see the changes instantly. If you modify your rust code\nor anything in the Cargo.toml, the window will close while rust recompiles. When\nfinished it will reload. If you need to get deeper insight into your current\nproject, or triage requires investigation of installed components, just run: ```\nyarn tauri info ``` ### What does the Release flow look like? The release flow\nbegins with proper configuration in the `tauri.conf.json` file. In this file,\nthe developer can configure not only the basic behaviour of the application\n(like window size and decoration), they can also provide settings for signing\nand updating. Depending upon the operating system that the developer (or CI) is\nbuilding the application on, there will be an app built for them for that\nsystem. (Cross compilation is not currently available, however there is an\nofficial [GitHub Action](https://github.com/tauri-apps/tauri-action) that can be\nused to build for all platforms.) To kick off this process, just: ``` yarn tauri\nbuild ``` After some time, the process will end and you can see the results in\nthe `./src-tauri/target/release` folder. ### What does the End-User flow look\nlike? End users will be provided with binaries in ways that are appropriate for\ntheir systems. Whether macOS, Linux, or Windows, direct download or store\ninstallations - they will be able to follow procedures for installing and\nremoving that they are used to. ### What does the Updating flow look like? When\na new version is ready, the developer publishes the new signed artifacts to a\nserver (that they have configured within `tauri.conf.json`). The application can\npoll this server to see if there is a new release. When there is a new release,\nthe user is prompted to update. The application update is downloaded, verified\n(checksum & signature), updated, closed, and restarted. ## License Tauri itself\nis licensed under MIT or Apache-2.0. If you repackage it and modify any source\ncode, it is your responsibility to verify that you are complying with all\nupstream licenses. Tauri is provided AS-IS with no explicit claim for\nsuitability for any purpose. Here you may peruse our [Software Bill of\nMaterials](https://app.fossa.com/projects/git%2Bgithub.com%2Ftauri-apps%2Ftauri).","url":"https://tauri.studio/docs/architecture"},{"id":"prose_docs_faq_md","title":"Frequently Asked Questions","headings":["error"],"subHeadings":[],"code":[null],"text":"## error: could not find native static libraryWebView2LoaderStatic, perhaps an\n-L flag is missing? The WebView2 crate build pipeline requires `NuGet` to have a\n`PackageSource` to install the `Microsoft.Web.WebView2` package. If you have\nnever used `NuGet` before, you might need to create a file named `NuGet.Config`\non `%APPDATA%/NuGet` folder, with the following contents: ``` ``` This\nconfiguration enables the default `NuGet` registry.","url":"https://tauri.studio/docs/faq"},{"id":"prose_docs_about_architecture_md","title":"The Tauri Architecture","area":"about","section":"about","headings":["What does the Release flow look like"],"subHeadings":[],"code":[null],"text":"# The Tauri Architecture ## Introduction Tauri is a polyglot and generic toolkit\nthat is very composable and allows engineers to make a wide variety of\napplications. It is used for building applications for Desktop Computers using a\ncombination of Rust tools and HTML rendered in a Webview. Apps built with Tauri\ncan ship with any number of pieces of an optional JS API / Rust API so that\nwebviews can control the system via message passing. In fact, developers can\nextend the default API with their own functionality and bridge the Webview and\nRust-based backend easily. Tauri apps can have custom menus and have tray-type\ninterfaces. They can be updated, and are managed by the user's operating system\nas expected. They are very small, because they use the OS's webview. They do not\nship a runtime, since the final binary is compiled from Rust. This makes the\nreversing of Tauri apps not a trivial task. ## What Tauri is NOT - Tauri is not\na lightweight kernel wrapper...instead it directly uses [WRY](#wry) and\n[TAO](#tao) to do the heavy-lifting in making system calls to the OS. - Tauri is\nnot a VM or virtualized environment...instead it is an application toolkit that\nallows making Webview OS applications. ## Major Components The following section\nbriefly describes the roles of the various parts of Tauri. ### Tauri Core\n[STABLE RUST] ####\n[tauri](https://github.com/tauri-apps/tauri/tree/dev/core/tauri) This is the\nmajor crate that holds everything together. It brings the runtimes, macros,\nutilities and API into one final product. It reads the `tauri.conf.json` file at\ncompile time in order to bring in features and undertake actual configuration of\nthe app (and even the `Cargo.toml` file in the project's folder). It handles\nscript injection (for polyfills / prototype revision) at runtime, hosts the API\nfor systems interaction, and even manages updating. ####\n[tauri-build](https://github.com/tauri-apps/tauri/tree/dev/core/tauri-build)\nApply the macros at build-time in order to rig some special features needed by\n`cargo`. ####\n[tauri-codegen](https://github.com/tauri-apps/tauri/tree/dev/core/tauri-codegen)\n- Embed, hash, and compress assets, including icons for the app as well as the\nsystem-tray. - Parse `tauri.conf.json` at compile time and generate the Config\nstruct. ####\n[tauri-macros](https://github.com/tauri-apps/tauri/tree/dev/core/tauri-macros)\nCreate macros for the context, handler, and commands by leveraging the\n`tauri-codegen` crate. ####\n[tauri-runtime](https://github.com/tauri-apps/tauri/tree/dev/core/tauri-runtime)\nThis is the glue layer between tauri itself and lower level webview libraries.\n####\n[tauri-runtime-wry](https://github.com/tauri-apps/tauri/tree/dev/core/tauri-runtime-wry)\nThis crate opens up direct systems-level interactions specifically for WRY, such\nas printing, monitor detection, and other windowing related tasks.\n`tauri-runtime` implementation for WRY. ####\n[tauri-utils](https://github.com/tauri-apps/tauri/tree/dev/core/tauri-utils)\nThis is common code that is reused in many places and offers useful utilities\nlike parsing configuration files, detecting platform triples, injecting the CSP,\nand managing assets. ### Tauri Tooling ####\n[api](https://github.com/tauri-apps/tauri/tree/dev/tooling/api) [TS -> JS] A\ntypescript library that creates `cjs` and `esm` Javascript endpoints for you to\nimport into your Frontend framework so that the Webview can call and listen to\nbackend activity. We also ship the pure typescript, because for some frameworks\nthis is more optimal. It uses the message passing of webviews to their hosts.\n#### [bundler](https://github.com/tauri-apps/tauri/tree/dev/tooling/bundler)\n[RUST / SHELL] The bundler is a library that builds a Tauri App for the platform\ntriple it detects / is told. At the moment it currently supports macOS, Windows\nand Linux - but in the near future will support mobile platforms as well. May be\nused outside of Tauri projects. ####\n[cli.js](https://github.com/tauri-apps/tauri/tree/dev/tooling/cli.js) [JS]\nWritten in Typescript and packaged such that it can be used with `npm`, `pnpm`,\nand `yarn`, this library provides a node.js runner for common tasks when using\nTauri, like `yarn tauri dev`. For the most part it is a wrapper around\n[cli.rs](https://github.com/tauri-apps/tauri/blob/dev/tooling/cli). ####\n[cli.rs](https://github.com/tauri-apps/tauri/tree/dev/tooling/cli) [RUST] This\nrust executable provides the full interface to all of the required activities\nfor which the CLI is required. It will run on macOS, Windows, and Linux. ####\n[create-tauri-app](https://github.com/tauri-apps/tauri/tree/dev/tooling/create-tauri-app)\n[JS] This is a toolkit that will enable engineering teams to rapidly scaffold\nout a new tauri-apps project using the frontend framework of their choice (as\nlong as it has been configured). # External Crates The Tauri-Apps organisation\nmaintains two \"upstream\" crates from Tauri, namely TAO for creating and managing\napplication windows, and WRY for interfacing with the Webview that lives within\nthe window. ## [TAO](https://github.com/tauri-apps/tao) Cross-platform\napplication window creation library in Rust that supports all major platforms\nlike Windows, macOS, Linux, iOS and Android. Written in Rust, it is a fork of\n[winit](https://github.com/rust-windowing/winit) that we have extended for our\nown needs like menu bar and system tray. ##\n[WRY](https://github.com/tauri-apps/wry) WRY is a cross-platform WebView\nrendering library in Rust that supports all major desktop platforms like\nWindows, macOS, and Linux. Tauri uses WRY as the abstract layer responsible to\ndetermine which webview is used (and how interactions are made). ##\n[tauri-hotkey-rs](https://github.com/tauri-apps/tauri-hotkey-rs) We needed to\nfix hotkey to work on all platforms, because upstream was not being responsive.\n# Additional tooling ##\n[binary-releases](https://github.com/tauri-apps/binary-releases) This is the\ndelivery mechanism for tauri prebuilt binaries: currently the cli.rs (used by\ncli.js) and rustup binaries (used by the deps install command of cli.js). These\nartifacts are automatically created on release. ##\n[tauri-action](https://github.com/tauri-apps/tauri-action) This is a github\nworkflow that builds tauri binaries for all platforms. It is not the fastest out\nthere, but it gets the job done and is highly configurable. Even allowing you to\ncreate a (very basic) tauri app even if tauri is not setup. ##\n[create-pull-request](https://github.com/tauri-apps/create-pull-request) Because\nthis is a very risky (potentially destructive) github action, we forked it in\norder to have strong guarantees that the code we think is running is actually\nthe code that is running. ##\n[vue-cli-plugin-tauri](https://github.com/tauri-apps/vue-cli-plugin-tauri) This\nplugin allows you to very quickly install tauri in a vue-cli project. ##\n[tauri-vscode](https://github.com/tauri-apps/tauri-vscode) This project enhances\nthe VS Code interface with several nice-to-have features. # Tauri Plugins\n[documentation](https://tauri.studio/en/docs/guides/plugin) Generally speaking,\nplugins are authored by third parties (even though there may be official,\nsupported plugins). A plugin generally does 3 things: 1. It provides rust code\nto do \"something\". 2. It provides interface glue to make it easy to integrate\ninto an app. 3. It provides a JS API for interfacing with the rust code. Here\nare several examples of Tauri Plugins: -\nhttps://github.com/tauri-apps/tauri-plugin-sql -\nhttps://github.com/tauri-apps/tauri-plugin-stronghold -\nhttps://github.com/tauri-apps/tauri-plugin-authenticator # Workflows ## What\ndoes the Development flow look like? A developer must first install the\nprerequisite toolchains for creating a Tauri app. At the very least this will\nentail installing rust & cargo, and most likely also a modern version of node.js\nand potentially another package manager. Some platforms may also require other\ntooling and libraries, but this has been documented carefully in the respective\nplatform docs. Because of the many ways to build front-ends, we will stick with\na common node.js based approach for development. (Note: Tauri does not by\ndefault ship a node.js runtime.) The easiest way to do this is to run the\nfollowing: ``` npx create-tauri-app ``` Which will ask you a bunch of questions\nabout the framework you want to install and then create everything you need in a\nsingle folder - some via the placement of template files and some through normal\ninstallation procedures of your framework. > If you don't use this process, you\nwill have to manually install the tauri cli, initialise tauri and manually\nconfigure the `tauri.conf.json` file. Once everything is installed, you can run:\n``` yarn tauri dev -or- npm run tauri dev ``` This will do several things: 1.\nstart the JS Framework devserver 2. begin the long process of downloading and\ncompiling the rust libraries 3. open an application window with devtools enabled\n4. keep a long-lived console alive If you change your HTML/CSS/TS/JS, your\nframework devserver should give you its best shot at instant hot module\nreloading and you will see the changes instantly. If you modify your rust code\nor anything in the Cargo.toml, the window will close while rust recompiles. When\nfinished it will reload. If you need to get deeper insight into your current\nproject, or triage requires investigation of installed components, just run: ```\nyarn tauri info ``` ## What does the Release flow look like? The release flow\nbegins with proper configuration in the `tauri.conf.json` file. In this file,\nthe developer can configure not only the basic behaviour of the application\n(like window size and decoration), they can also provide settings for signing\nand updating. Depending upon the operating system that the developer (or CI) is\nbuilding the application on, there will be an app built for them for that\nsystem. (Cross compilation is not currently available, however there is an\nofficial [GitHub Action](https://github.com/tauri-apps/tauri-action) that can be\nused to build for all platforms.) To kick off this process, just: ``` yarn tauri\nbuild ``` After some time, the process will end and you can see the results in\nthe `./src-tauri/target/release` folder. ## What does the End-User flow look\nlike? End users will be provided with binaries in ways that are appropriate for\ntheir systems. Whether macOS, Linux, or Windows, direct download or store\ninstallations - they will be able to follow procedures for installing and\nremoving that they are used to. ## What does the Updating flow look like? When a\nnew version is ready, the developer publishes the new signed artifacts to a\nserver (that they have configured within `tauri.conf.json`). The application can\npoll this server to see if there is a new release. When there is a new release,\nthe user is prompted to update. The application update is downloaded, verified\n(checksum & signature), updated, closed, and restarted. ## License Tauri itself\nis licensed under MIT or Apache-2.0. If you repackage it and modify any source\ncode, it is your responsibility to verify that you are complying with all\nupstream licenses. Tauri is provided AS-IS with no explicit claim for\nsuitability for any purpose. Here you may peruse our [Software Bill of\nMaterials](https://app.fossa.com/projects/git%2Bgithub.com%2Ftauri-apps%2Ftauri).","url":"https://tauri.studio/docs/about/architecture"},{"id":"prose_docs_about_book_md","title":"Get the book","area":"about","section":"about","headings":["Outline","Errata"],"subHeadings":["tl","Introduction","About the Topic","What you will learn","Stuff you","Chapter 1 ","Chapter 2 ","Chapter 3 ","Chapter 4 ","Chapter 5 "],"code":[null],"text":"import useBaseUrl from '@docusaurus/useBaseUrl' # Get the book\nTauri - From Theory to Practice [{useBaseUrl('img/bookCover.png')}]\n:::info Tauri: From Theory to Practice\nArchitecting Next-Gen Native-Apps for all Platforms [v1:Rust Edition]\nAuthors: [Daniel Thompson-Yvetot, Lucas Fernandes Gonçalves Nogueira]\nPublisher: TBD\nRelease: late 2020 ::: ### tl;dr; Visit https://opencollective.com/tauri and\npreorder your copy of the book today. Your donation will support the ongoing\ndevelopment of Tauri, and you will receive advance digital PDF's for your review\nas chapters are completed. The final book will ship concurrently with the\nrelease of 1.0.0 stable. If you donate 10 USD / month to Tauri, you will get the\nadvance PDF versions as soon as they are released. If you just want to donate\nonce: 15 USD for PDF and e-book, 30 USD for print version and PDF, 40 USD for\nall three. All tutorial subscription tiers receive the rolling PDF free of\nadditional charge. ### Introduction In 2020, the manufacture of native-apps has\nbecome easier and more accessible than ever before. All the same, beginners and\nseasoned developers alike are confronted with tough choices in a rapidly\nchanging landscape of security and privacy. This is especially true in the\nsemi-trusted environment of user devices. Tauri takes the guesswork out of the\nequation, as it was designed from the ground up to embrace new paradigms of\nsecure development and creative flexibility that leverage the language features\nof Rust and lets you build an app using any frontend framework you like. Find\nout how you can design, build, audit and deploy tiny, fast, robust, and secure\nnative applications for the major Desktop and Mobile platforms, all from the\nexact same codebase and in record time - without even needing to know the Rust\nprogramming language. Authors Daniel and Lucas, the architects behind Tauri take\nyou on a journey from theory to execution, during which you will learn why Tauri\nwas built and how it works under the hood. Together with guest personalities\nthat specialize in Open Source, DevOps, Security and Enterprise Architecture,\nthis book also presents discourse-formatted philosophical discussions and\nopen-source sustainability viewpoints from which your next-gen apps will profit\n- and your users will benefit. In this book you will follow the authors in the\niterative evolution of a real project from conception to distribution - all with\ncommentary, complete code resources, built, and packaged Native Apps for\nreference and staged Capture the Flag (CTF) challenges that progress in\ndifficulty as your comprehension of the system grows. ### About the Topic Tauri\nis a brand new way to make cross-platform native-apps for web, desktop and\nmobile. At this very moment, the pre-alpha version of this MIT licensed\ncommunity-based software is being prepared for public release:\nhttps://github.com/tauri-apps/tauri Tauri introduces novel methods for WebView\nintegration and innovative patterns for robust threat evasion. The 1.0 release\nwill ship with a multipurpose white-box analyzer and decompiler for any kind of\nbinary and an integrated CLI for ingesting any type of HTML; which, when\ncombined, provides developers and security teams with a holistic platform that\nhas never existed as a single unit before. Tauri bridges communities and opens\nup new opportunities for everyone from the front end developer all the way to\nthe low-level security and network administrators. Due to this level of\ncomplexity and robustness, it is important to publish a reference guide that\nwill necessarily be updated as major versions are released. ### What you will\nlearn By the end of this book you will understand: - The method and reasoning\nbehind the design of Tauri - The options you have when building with Tauri -\nThat having a moral compass is possible in software development - Why the Rust\nlanguage makes the most sense as a binding and application layer - Why Electron,\nCordova, React Native, Capacitor and others are no longer the best choice - Why\na binary review is important And you will be able to: - Transform a simple\nwebsite project into a Tauri Native-App - Make a variety of Tauri Application\nTypes based on the main Patterns - Decompile and analyze your App for Security\nIssues - Publish your App to a variety of App Stores - Read and write Rust code\n### Stuff you'll get if you preorder - Access to a real demo App built for all\nplatforms available at respective stores (that includes CTF Flags). - Exclusive\nOne-Pager cheat sheets made available for each section of the book, including\nthe Appendices. - Early access to videos / webcasts. - Discounted participation\nin the “Capture the Flag” event hosted at the launch of the book. ## Outline\nThis is an early outline of the contents that we expect to publish. Contents\nsubject to change. ### Chapter 1 - Theory (ca. 50 pages - mostly conversational\n/ technical, graphics) ``` 1. Security Starts with You 2. Privacy Ends with\n${you} 3. Languages, Dialects and Patterns 4. Toolchains and Syntactic Sugar 5.\nProduction Methodologies 6. Enterprise Readiness 7. Message Queueing 8.\nEmbracing Chaos 9. Distribution Techniques 10. Licensing Strategies ``` ###\nChapter 2 - Practice (ca. 130 pages w/ charts, screenshots, code samples) ``` 1.\nEnvironment Prerequisites - Node, Npm, Yarn, Rustc, Rustup, Buildtools 2.\nDevelopment Platform Details - macOS - Windows - Linux - Docker - Virtual\nMachines - CI / CD 3. Tauri Introduction 4. Tauri Anatomy 5. Tauri Configuration\n- Files & Folders - Icons - Splash Screens - Window -\n`src-tauri/tauri.conf.json` 6. Preparing your code - Transpile dynamic imports -\nRemove webpack chunking - Monolithic Files - Minification strategies 7. Tauri\nAPI - Design Considerations - API Usage Patterns - Custom API Functions -\nEndpoints - All - Answer - Bridge - Event - Execute - List Files - Open - Read\nBinary File - Read Text File - Set Title - Window - Write File 8. Web APIs 9.\nTauri App Extensions - Anatomy - Flow - Registration - Publication - API 10.\nTaskbar Integration (Desktop Only) - Anatomy - Integrations - macOS - Windows -\nLinux 11. Security Features - Baseline Rust Features - Functional Address Space\nLayout Randomization (fASLR) - Ahead of Time (AoT) Compilation - Content\nSecurity Policy (CSP) - One Time Pads (OTP) - Embedded Server: False - API\nTree-Shaking - Matryoschkasumming (with Tauri-Frida) 12. Bridges and Brokers -\nBridge Patterns - Message hashing with OTP - Plugin Pattern - Kamikaze Function\nInjection (KFI) Closures 13. Testing - Unit Testing - Rust - JS - Integration\nTesting - e2e Testing 14. Building - Debugging - Packaging - Minification -\nDistribution Platform Details - macOS (.app / .dmg) - Win (.exe / .msi) - Linux\nArm64 (.appImage / .deb) - Linux x64 (.appImage / .deb) - iOS (.ipa) - Android\n(.apk) - PWA Website (with wasm) - Code Signing - Keystores - Certs -\nFingerprints - Providing License for End Users - Providers - Keys Files -\nSelf-Updater - Anatomy - Service Provisioning - Github - AWS - Homegrown -\nCross-Platform Bundler 15. Tauri-Frida Harness - Introduction to Reverse\nEngineering - Toolchain - Usage - Binary Hooking at Runtime - Pointer Evaluation\n- Spraying, Fuzzing, Spoofing - Report Generation - Recompilation - Post-Binary\nAnalysis 16. Distribution - Git - Mac Store - iOS Store - Play store - Windows\nStore - Snap Store - PureOS Store - .deb channels - .tar.gz - homebrew - Fdroid\n- Cydia - ChromeOS - WASM ``` ### Chapter 3 - Philosophical Discourses (ca. 40\npages of essays, some graphics) ``` 1. Rights and Responsibilities (with Robin\nvan Boven (SFOSC)) - Who You are Responsible To - Being a Vendor Comes with\nDuties - Ubiquitous Resources are Still Precious - Use Policy to Address\nResponsibilities - Take a Hippocratic Development Oath 2. Take a More Secure\nStance (with Liran Tal (SNYK)) - Security Benefits of Frameworks - Encrypt All\nthe Things, All the Time - Constantly Audit Project Dependencies - Harden\nYourself, Your Organization and Your Ecosystem - “Do What You Can Until You Run\nOut of Time.” - [ROBERT C. SEACORD] 3. Production Strategies for Sustainability\n(with Rhys Parry (Independent)) - Develop in the “Perfect” Environment - Minimal\nImpact for Existing Enterprise Architectures - Use Low-Barrier Tools for\nEnsuring Wholestack Security - Test the Right Things Intelligently - Post-Binary\nAnalysis and Redistribution - The Last Mile ``` ### Chapter 4 - Execution (ca.\n100 pages w/ code examples, screenshots, graphics) ``` 1. Base Pattern Evolution\n- Hermit - Bridge - Cloudish - Cloudbridge - Lockdown - Multiwin - GLUI 2.\nAdvanced Patterns - Cryptographic Enclave - Identity Management - Combine an App\nwith a Daemon - IPC / RPC - Integrate with DENO 3. UI Source Complilation -\nReact - Vue - Angular - Svelte - Gatsby 4. Building a Real App - Multiparty\nPassword Manager - Design - Prototyping - Testing - Debugging - Packaging -\nChecksumming 5. Tauri-Frida - White Box Reversing - Analyzing with Frida - Chaos\nExperiments - Interface Jacking - Disk Change - Latency - Process Kill - CPU\nThrottle - Static Analysis Reporting - Binary Repackaging - Inject License Keys\n- Clear Dead Codepoints - Recalculate Integrated Checksum 6. Publishing the App\n- Git - Mac Store - iOS Store - Play store - Windows Store - Snap Store - PureOS\nStore - .deb channels - .tar.gz - homebrew - Fdroid - Cydia - ChromeOS - WASM 7.\nPublishing an Update ``` ### Chapter 5 - Appendices (ca. 120 pages) ``` 1.\nConfiguration Options 2. Files and Repositories 3. Tauri CLI references 4. Tauri\nAPI references 5. ES6 References 6. Rust References 7. App Pattern Charts 8.\nTauri-Frida Reference 9. Glossary 10. Index ``` ## Errata Got something that you\nthink should be in the book? Want to be our publisher? Reach out to us and let\nus know!","url":"https://tauri.studio/docs/about/book"},{"id":"prose_docs_about_governance_md","title":"Governance","area":"about","section":"about","headings":["Sustainability"],"subHeadings":["Organizational Structure","Code of Conduct","Social Contract","Licensing","Trademark"],"code":[],"text":"# Governance ## Sustainability One of the main goals of the organizational\nstructure of Tauri is to guarantee the sustainability of Tauri and the health\nand well-being of its contributors. The world of Open Source is fraught with\nperil and discord, and we have taken measures to ensure the longevity of Tauri.\nThis document explains how we go about doing so. ### Organizational Structure\nTauri apps is governed by the community and work is done in the context of\npublic working groups. Each working group has a dedicated channel on the Discord\nserver as well as a Team on GitHub. Other than that, each WG is free to use\nwhatever type of organizational model it chooses. The current working groups\nare: - WG Governance & Guidance - WG Tech - WG Education - WG Media - WG\nSecurity - WG Devops With the exception of the security working group, which is\nby invite only and convenes privately, all other working groups are public and\nopen to any and all participants. Please visit [this\nrepository](https://github.com/tauri-apps/governance-and-guidance) to get more\ninformation. ### Code of Conduct Everyone participating in the Tauri community\nis expected to follow a code of conduct that you can at the [Governance and\nGuidance:Code of\nConduct](https://github.com/tauri-apps/governance-and-guidance/blob/master/CODE_OF_CONDUCT.md).\n### Social Contract We have a Social Contract that informs our decision making\nand organization. You can read about it here: [Governance and Guidance:Social\nContract](https://github.com/tauri-apps/governance-and-guidance/blob/master/SOCIAL_CONTRACT.md).\n### Licensing We, the contributors to Tauri Apps, use the MIT and Apache\nlicenses for all code content. Images and bodies of text, unless otherwise noted\nare CC-BY-ND-NC. ### Trademark It is a permissible use of the name \"Tauri App\"\nor the Tauri logo to show that a project uses Tauri. \"Tauri Studio\" is reserved\nfor use by the organization. Any language that gives the impression that the\nTauri organization approves, authorizes or otherwise supports a project, person\nor company is not permissible without written authorization from the Guidance\nand Governance Working Group.","url":"https://tauri.studio/docs/about/governance"},{"id":"prose_docs_about_intro_md","title":"What is Tauri","area":"about","section":"about","headings":["Security First","Polyglots","Honest Open Source","The Future"],"subHeadings":[],"code":[],"text":"# What is Tauri? Tauri is a toolkit that helps developers make applications for\nthe major desktop platforms - using virtually any frontend framework in\nexistence. The core is built with Rust, and the CLI leverages Node.js making\nTauri a genuinely polyglot approach to creating and maintaining great apps. If\nyou want to know more about the technical details, then please visit the\n[Introduction](/docs/getting-started/beginning-tutorial). If you want to know\nmore about this project's philosophy - then keep reading.\n\n## Security First In today's world, every honest threat model assumes that the\nuser's device has already been compromised. This puts app developers in a\ncomplicated situation because if the device is already at risk, how can the\nsoftware be trusted? Defense in depth is the approach we've taken. We want you\nto be able to take every precaution possible to minimize the surface area you\npresent to attackers. Tauri lets you choose which API endpoints to ship, whether\nor not you want a localhost server built into your app, and it even randomizes\nfunctional handles at runtime. These and other techniques form a secure baseline\nthat empowers you and your users. Slowing down attackers by making static\nattacks crushingly difficult and isolating systems from one another is the name\nof the game. And if you are coming from the Electron ecosystem - rest assured -\nby default Tauri only ships binaries, not ASAR files. By choosing to build Tauri\nwith security as a guiding force, we give you every opportunity to take a\nproactive security posture. ## Polyglots, not Silos Most contemporary frameworks\nuse a single language paradigm and are therefore trapped in a bubble of\nknowledge and idiom. This can work well for certain niche applications, but it\nalso fosters a kind of tribalism. This can be seen in the way that the React,\nAngular, and Vue development communities huddle on their stacks, ultimately\nbreeding very little cross-pollination. This same situation can be seen in the\nRust vs. Node vs. C++ battlefields, where hardliners take their stances and\nrefuse to collaborate across communities. Today, Tauri uses Rust for the backend\n- but in the not too distant future, other backends like Go, Nim, Python,\nCsharp, etc. will be possible. This is because we are maintaining the official\nRust bindings to the [webview](https://github.com/webview) organization and plan\nto let you switch out the backend for your needs. Since our API can be\nimplemented in any language with C interop, full compliance is only a PR away.\n## Honest Open Source None of this would make any sense without a community.\nToday software communities are amazing places where people help each other and\nmake awesome things - open source is a very big part of that. Open source means\ndifferent things to different people, but most will agree that it serves to\nsupport freedom. When software doesn't respect your rights, then it can seem\nunfair and potentially compromise your freedoms by operating in unethical ways.\nThis is why we are proud that FLOSS advocates can build applications with Tauri\nthat are \"certifiably\" open source and can be included in FSF endorsed GNU/Linux\ndistributions. ## The Future Tauri's future depends on your involvement and\ncontributions. Try it out, file issues, join a working group or make a donation\n- every contribution is important. Please, at any rate, do get in touch!!!","url":"https://tauri.studio/docs/about/intro"},{"id":"prose_docs_about_security_md","title":"Security","area":"about","section":"about","headings":["No Server Required","Language Features of Rust","Dynamic Ahead of Time Compilation ","Function Hardening","System Features","Ecosystem","Future Work"],"subHeadings":["Security Researchers","Functional ASLR","Kamikaze Function Injection","Bridge","One Time Pad Tokenization and Hashing","Allowing API","Content Security Policy Management","Decompilation is Difficult","Build Pipelines and Artifact Authenticity","Resilient PR and Approval Processes","Signed Binaries","Post","Post","Audits"],"code":[],"text":"# Security This guide seeks to explain the high-level concepts and Security\nFeatures at the core of Tauri's design that makes you, your apps, and your users\nsafer by default. ::: Please note:\nWhile we take every opportunity to help you harden your application - there are\nalways underlying threats like BIOS attacks, memory rowhammering and other\noperating system vulnerabilities that are constantly being discovered and (in\nthe best cases) responsibly disclosed.\nFurthermore, there are many ways that development teams can cut corners and\neither leak sensitive information or leave doors wide open to any of a range of\nattacks. Security is a never-ending quest, and your users count on you to keep\nthem safe.\nTherefore, we highly recommend that you take some time to consider the security\nramifications of everything that your application does, especially in the\ncontext of running on the semi-hostile platform of end-user devices.\nIf you need help or want a review, you are welcome to contact the Tauri team for\nsecurity consultation. ::: ### Security Researchers If you feel that there is a\nsecurity concern or issue with anything in Tauri, please do not publicly comment\non your findings. Instead, reach out directly to our security team: >\nsecurity@tauri.studio Although we do not currently have a budget for Security\nBounties, in some cases, we will consider rewarding responsible disclosure with\nour limited resources. ## No Server Required Tauri enables you to construct an\napplication that uses web technology for the user interface without requiring\nyou to use a server to communicate with the backend. Even if you used advanced\ntechniques of dynamic imports and offload work to the backend, no traffic can be\nsniffed on TCP ports or external processes - because they aren't there. This\nreduces not only the physical and virtual footprint of your final binary by a\ngood deal, but it also reduces the surface area of potential attack vectors by\nremoving them from the equation. ## Language Features of Rust By turning to the\nprogramming language renowned for its memory safety and speed, Tauri simply\nerases whole classes of conventional attacks. `Use after free` just isn't\nsomething that can happen with Tauri. ## Dynamic Ahead of Time Compilation (AOT)\nThis compilation process happens several times during the bootstrapping phase of\na Tauri app. Using our default dynamic Ahead of Time compiler, you can generate\ncode references that are unique for every session and are still technically\nstatic code units. ## Function Hardening ### Functional ASLR Functional address\nSpace Layout Randomization techniques randomize function names at runtime and\ncan implement OTP hashing, so no two sessions are ever the same. We propose a\nnovel type of function naming at boot time and optionally after every execution.\nUsing a UID for each function pointer prevents static attacks. ### Kamikaze\nFunction Injection This advanced type of fASLR using the `EVENT` API endpoint is\na promise wrapped in a closure (with randomized handle) that Rust inserts at\nruntime into the WebView, where its interface is locked within the promise\nresolution handler and is nulled after execution. ### Bridge, don't serve\nInstead of passing potentially unsafe functions, an event bridge can be used to\npass messages and commands to named brokers at each respective side of the\napplication. ### One Time Pad Tokenization and Hashing Hashing important\nmessages with an OTP salt, you are able to encrypt messages between the user\ninterface and the Rust backend. We are currently investigating the use of\nadditional sources of entropy, such as the amazing [Infinite Noise\nTRNG](https://13-37.org/en/shop/infinite-noise-trng/). ## System Features ###\nAllowing API You have the ability to pick and choose which API functions are\navailable to the UI and to Rust. If they are not enabled, the code will not be\nshipped with your app, which reduces binary size and attack surface. They are\nopt-in, so you have to consciously choose to progressively enhance your\napplication. ### Content Security Policy Management Preventing unauthorized code\nexecution for websites has long since been \"resolved\" by using CSPs. Tauri can\ninject CSPs into the index.html of the user interface, and when using a\nlocalhost server, it will also send these headers to the UI or any other clients\nthat connect with it. ### Decompilation is Difficult This means that your apps\ncannot be easily decompiled, as is the case with Electron ASAR files, which\nmakes the process of reverse engineering your project much more time-intensive\nand requires specialist training. ## Ecosystem ### Build Pipelines and Artifact\nAuthenticity The process of releasing our source-code artifacts is highly\nautomated yet mandates kickoff and review from real humans. Our current release\nstrategy uses a combination of Github Actions and IOTA Tangle publication ###\nResilient PR and Approval Processes Our WG-TECH reviews code changes, tags PRs\nwith scope, and makes sure that everything stays up to date. And when its time\nto publish a new version, one of the maintainers tags a new release on master,\nwhich: - validates core - runs smoke tests - audits security for crates and npm\n- generates changelogs - creates artifacts - publishes checksums to IOTA -\ncreates a draft release Then the maintainer reviews the release notes, edits if\nnecessary - and a new release is forged. ## Future Work ### Signed Binaries\nBecause the entire project is shipped within a monolithic binary, code can be\nsigned for all distributables. (Currently using external tooling, but we are\nactively working on making the bundler a one-stop-shop.) This makes it virtually\nimpossible for hackers to change an installed Application without the operating\nsystem noticing. [Reference](https://github.com/electron/asar/issues/123) ###\nPost-Binary Analysis Use industrial-grade pentester-tooling (via our forthcoming\nTauri-Frida GUI) to discover and fix security weaknesses in your final binaries.\n### Post-Binary Enhancement After the build is before the delivery and Tauri\nwill provide you with tools never seen before. Stay tuned! ### Audits We are\ncurrently in the process of our first external audit. When complete, we will\npublish the results here.","url":"https://tauri.studio/docs/about/security"},{"id":"prose_docs_architecture_build_tools_md","title":"Node Build Tools","area":"architecture","section":"architecture","headings":[],"subHeadings":[],"code":[],"text":"This is a stub. Could add notes about Vite, Webpack, Rollup, etc.","url":"https://tauri.studio/docs/architecture/build-tools"},{"id":"prose_docs_architecture_frontend_frameworks_md","title":"Frontend Frameworks","area":"architecture","section":"architecture","headings":[],"subHeadings":[],"code":[],"text":"This is a stub. Could add notes about Vite, Webpack, Rollup, etc.","url":"https://tauri.studio/docs/architecture/frontend-frameworks"},{"id":"prose_docs_architecture_patterns_brownfield_md","title":"Brownfield Pattern","area":"architecture","section":"patterns","headings":["Incompatibilities","Configuration"],"subHeadings":[],"code":["json"],"text":"# Brownfield Pattern _**This is the default pattern.**_ This is the simplest and\nmost straightforward pattern to use Tauri with due to it trying to be the most\ncompatible with existing frontend projects as much as it can. In short, it tries\nto require nothing additional to what an existing web frontend might use inside\na browser. Not _**everything**_ that works in existing browser applications will\nwork out-of the box, see the [Incompatibility section](#incompatibilities) for\nmore details. If you are unfamiliar with Brownfield software development in\ngeneral, the [Brownfield Wikipedia\narticle](https://en.wikipedia.org/wiki/Brownfield_(software_development))\nprovides a nice summary of it. For Tauri, the existing software is current\nbrowser support and behavior instead of legacy systems. ## Incompatibilities The\nfirst incompatibility category is easy, any browser-specific APIs will not work\nproperly inside Tauri (even while using the Brownfield pattern). If the API is\nnot widely supported across browsers, it's likely not going to be supported\nacross all platforms while using Tauri. The second incompatibility category is\nfeatures that are planned for Tauri but are currently not fully implemented.\nHere is a list of examples: * [WebRTC support on\nLinux](https://github.com/tauri-apps/wry/issues/85) * [Some permissions\nAPIs](https://github.com/tauri-apps/wry/issues/81) * [Download Links/Blob as\nURL](https://github.com/tauri-apps/wry/issues/349) * [Better\ni18n](https://github.com/tauri-apps/wry/issues/442) ## Configuration Because the\nBrownfield pattern is the default pattern, no configuration option is required\nto be set. To explicitly set it, you can use the `tauri > pattern` object in the\n`tauri.conf.json` configuration file. ```json { \"tauri\": { \"pattern\": { \"use\":\n\"brownfield\" } } } ``` _**There are no additional configuration options for the\nbrownfield pattern.**_","url":"https://tauri.studio/docs/architecture/patterns/brownfield"},{"id":"prose_docs_architecture_patterns_isolation_md","title":"Isolation Pattern","area":"architecture","section":"patterns","headings":["Why","When","How","Recommendations","Creating the Isolation Application","Configuration"],"subHeadings":["Approximate Steps of an IPC Message","Performance Implications","Limitations"],"code":["html","js","json"],"text":"","url":"https://tauri.studio/docs/architecture/patterns/isolation"},{"id":"prose_docs_architecture_recipes_about_recipes_md","title":"A word on recipes","area":"architecture","section":"recipes","headings":[],"subHeadings":[],"code":[],"text":"Tauri recipes are descriptions of use-cases that are entirely configurable\nwithin the `src-tauri/tauri.conf.json` file. These are not the limits of what\nTauri can do, and there are probably more out there. If you discover one, why\nnot get in touch and help us update this collection! If you haven't read about\nthe general design of Tauri, then it would make the most sense for you to visit\nthe [\"Getting Started\"](/docs/getting-started/beginning-tutorial) and become\nfamiliar with the basic architecture and terminology used in these recipes.","url":"https://tauri.studio/docs/architecture/recipes/about-recipes"},{"id":"prose_docs_architecture_recipes_bridge_md","title":"Bridge","area":"architecture","section":"recipes","headings":["Description","Diagram","Configuration"],"subHeadings":[],"code":[],"text":"import Rater from '@theme/Rater' import useBaseUrl from '@docusaurus/useBaseUrl'\n\nEase of Use Extensibility Performance Security\n\nBridge [{useBaseUrl('img/recipes/Bridge.svg')}]\nPros:\n * Highly configurable\n * No Rust skills required\n\nCons:\n * Some WebAPIs unavailable\n * Challenge to implement\n\n## Description The Bridge recipe is a secure pattern where messages are passed\nbetween brokers via an implicit bridge using the API. It isolates functionality\nto scope and passes messages instead of functionality. ## Diagram import\nMermaid, { colors } from '@theme/Mermaid' F subgraph WEBVIEW F-.-E end D-->E\nE-->D B-->D D-->B subgraph RUST A==>H A-->B B-.-C B-.-G end A[Binary] B{Rust\nBroker} C[Subprocess 2] G[Subprocess 1] D(( API BRIDGE )) E{JS Broker} F[Window]\nH{Bootstrap} style D fill:#ccc,stroke:#333,stroke-width:4px,color:white style\nRUST fill:${colors.orange.light},stroke:${colors.orange.dark},stroke-width:4px\nstyle WEBVIEW\nfill:${colors.blue.light},stroke:${colors.blue.dark},stroke-width:4px`} /> ##\nConfiguration Here's what you need to add to your tauri.conf.json file: ```json\n{ \"tauri\": { \"allowlist\": { \"all\": false, \"clipboard\": { \"all\": false,\n\"readText\": false, \"writeText\": false }, \"dialog\": { \"all\": false, \"ask\": false,\n\"confirm\": false, \"message\": false, \"open\": false, \"save\": false }, \"fs\": {\n\"all\": false, \"copyFile\": false, \"createDir\": false, \"readDir\": false,\n\"readFile\": false, \"removeDir\": false, \"removeFile\": false, \"renameFile\": false,\n\"scope\": [], \"writeFile\": false }, \"globalShortcut\": { \"all\": false }, \"http\": {\n\"all\": false, \"request\": false, \"scope\": [] }, \"notification\": { \"all\": false },\n\"os\": { \"all\": false }, \"path\": { \"all\": false }, \"process\": { \"all\": false,\n\"exit\": false, \"relaunch\": false, \"relaunchDangerousAllowSymlinkMacos\": false },\n\"protocol\": { \"all\": false, \"asset\": false, \"assetScope\": [] }, \"shell\": {\n\"all\": false, \"execute\": false, \"open\": false, \"scope\": [], \"sidecar\": false },\n\"window\": { \"all\": false, \"center\": false, \"close\": false, \"create\": false,\n\"hide\": false, \"maximize\": false, \"minimize\": false, \"print\": false,\n\"requestUserAttention\": false, \"setAlwaysOnTop\": false, \"setDecorations\": false,\n\"setFocus\": false, \"setFullscreen\": false, \"setIcon\": false, \"setMaxSize\":\nfalse, \"setMinSize\": false, \"setPosition\": false, \"setResizable\": false,\n\"setSize\": false, \"setSkipTaskbar\": false, \"setTitle\": false, \"show\": false,\n\"startDragging\": false, \"unmaximize\": false, \"unminimize\": false } } } } ```","url":"https://tauri.studio/docs/architecture/recipes/bridge"},{"id":"prose_docs_architecture_recipes_cloudbridge_md","title":"Cloudbridge","area":"architecture","section":"recipes","headings":["Description","Diagram","Configuration"],"subHeadings":[],"code":[],"text":"import Rater from '@theme/Rater' import useBaseUrl from '@docusaurus/useBaseUrl'\n\nEase of Use Extensibility Performance Security\n\nCloudbridge [{useBaseUrl('img/recipes/Cloudbridge.svg')}]\nPros:\n * All available features\n * No Rust skills required\n\nCons:\n * Largest bundle size\n * Hard to separate concerns\n\n## Description The Cloudbridge recipe combines the flexibility of a localhost\nand the security of the bridge. With so many features, it can be easy to get\nlost. ## Diagram import Mermaid, { colors } from '@theme/Mermaid' F2 H==>D2\nD2-->F2 F2-->D2 B-->D D-->B E2-->D D-->E2 subgraph WEBVIEW F2 E2 end subgraph\nSERVER D2 E-->D2 end subgraph RUST A==>H A-->B B-.-C end A[Binary] B{Rust\nBroker} C[Subprocess] D(( API BRIDGE )) E{JS Broker} D2(( localhost )) E[bundled\nresources] E2{JS Broker} F2[Window] H{Bootstrap} style D\nfill:#ccc,stroke:#333,stroke-width:4px,color:white style RUST\nfill:${colors.orange.light},stroke:${colors.orange.dark},stroke-width:4px style\nWEBVIEW fill:${colors.blue.light},stroke:${colors.blue.dark},stroke-width:4px\nstyle SERVER fill:#49A24A,stroke:#2B6063,stroke-width:4px `} /> ## Configuration\nHere's what you need to add to your tauri.conf.json file: ```json \"tauri\": {\n\"allowlist\": { \"all\": true // enable entire API } } ```","url":"https://tauri.studio/docs/architecture/recipes/cloudbridge"},{"id":"prose_docs_architecture_recipes_cloudish_md","title":"Cloudish","area":"architecture","section":"recipes","headings":["Description","Diagram","Configuration"],"subHeadings":[],"code":[],"text":"import Rater from '@theme/Rater' import useBaseUrl from '@docusaurus/useBaseUrl'\n\nEase of Use Extensibility Performance Security\n\nCloudish [{useBaseUrl('img/recipes/Cloudish.svg')}]\nPros:\n * Similar to a SPA web-app\n * No Rust skills required\n\nCons:\n * No access to Rust API\n * Uses a localhost server\n\n## Description The Cloudish recipe is a pattern for maximum flexibility and app\nperformance. It uses a localhost server, which means that your app will\ntechnically be available to other processes, like browsers and potentially other\ndevices on the network. All of your assets are baked into the binary, but served\nas if they were distinct files. ## Diagram import Mermaid, { colors } from\n'@theme/Mermaid' F H==>D D-->F F-->D subgraph RUST A==>H end subgraph WEBVIEW F\nend subgraph SERVER D E-->D end A[Binary] D(( localhost )) E[bundled resources]\nF[Window] H{Bootstrap} style RUST\nfill:${colors.orange.light},stroke:${colors.orange.dark},stroke-width:4px style\nWEBVIEW fill:${colors.blue.light},stroke:${colors.blue.dark},stroke-width:4px\nstyle SERVER fill:#49A24A,stroke:#2B6063,stroke-width:4px`} /> ## Configuration\nHere's what you need to add to your tauri.conf.json file: ```json \"tauri\": {\n\"allowlist\": { \"all\": false // disable entire API } } ```","url":"https://tauri.studio/docs/architecture/recipes/cloudish"},{"id":"prose_docs_architecture_recipes_glui_md","title":"GLUI","area":"architecture","section":"recipes","headings":["Description","Diagram","Configuration"],"subHeadings":[],"code":[],"text":"import Alert from '@theme/Alert' import useBaseUrl from '@docusaurus/useBaseUrl'\nThis pattern is not available for now. import Rater from '@theme/Rater'\n\nEase of Use Extensibility Performance Security\n\nGLUI [{useBaseUrl('img/recipes/GLUI.svg')}]\nPros:\n * Framebuffer FTW\n * Window events rigged\n\nCons:\n * Broken on your machine\n\n## Description The GLUI is a research pattern that we will use internally to\ntest approaches using a GLUTIN window. We’re not sure yet if it will make the\nfinal cut as a bona fide alternative to WebView, although early tests with\ntransparent and multiwindow are exciting. ## Diagram import Mermaid, { colors }\nfrom '@theme/Mermaid' H H==>G A-->D D-->G subgraph GLUTIN G end subgraph RUST A\nend A[Binary] D(Framebuffer) G[GL Window] H{Bootstrap} style GLUTIN\nstroke:${colors.blue.dark},stroke-width:4px style RUST\nfill:${colors.orange.light},stroke:${colors.orange.dark},stroke-width:4px`} />\n## Configuration Here's what you need to add to your tauri.conf.json file:\n```json \"tauri\": { \"allowlist\": { // all API endpoints are default false \"all\":\nfalse, // disable the api }, \"window\": { // not yet normative \"glutin\": true,\n\"webview\": false } } ```","url":"https://tauri.studio/docs/architecture/recipes/glui"},{"id":"prose_docs_architecture_recipes_hermit_md","title":"Hermit","area":"architecture","section":"recipes","headings":["Description","Diagram","Configuration"],"subHeadings":[],"code":["json"],"text":"import Rater from '@theme/Rater' import useBaseUrl from '@docusaurus/useBaseUrl'\n\nEase of Use Extensibility Performance Security\n\nHermit [{useBaseUrl('img/recipes/Hermit.svg')}]\nPros:\n * Quick to make\n * Smallest size\n\nCons:\n * No remote resources\n * No access to API\n\n## Description The Hermit recipe is a pattern for ultimate application isolation\nwhere all logic is self-contained in the Window and the binary exists merely to\nbootstrap the Window. There is no communication back to Rust from the Window,\nthere is no localhost server, and the Window has no access to any remote\nresources. The Hermit is great for interactive Kiosk Mode and standalone HTML\nbased games. ## Diagram import Mermaid, { colors } from '@theme/Mermaid' H H==>F\nsubgraph WEBVIEW F end subgraph RUST A end A[fa:fa-cog Binary ]\nF[fa:fa-window-maximize Window] H{Bootstrap} style RUST\nfill:${colors.orange.light},stroke:${colors.orange.dark},stroke-width:4px style\nWEBVIEW fill:${colors.blue.light},stroke:${colors.blue.dark},stroke-width:4px`}\n/> ## Configuration Here's what you need to add to your tauri.conf.json file:\n```json \"tauri\": { \"allowlist\": { \"all\": false, // disable and tree-shake all\napi functions } } ```","url":"https://tauri.studio/docs/architecture/recipes/hermit"},{"id":"prose_docs_architecture_recipes_lockdown_md","title":"Lockdown","area":"architecture","section":"recipes","headings":["Description","Diagram","Configuration"],"subHeadings":[],"code":["json"],"text":"import Rater from '@theme/Rater' import useBaseUrl from '@docusaurus/useBaseUrl'\n\nEase of Use Extensibility Performance Security\n\nLockdown [{useBaseUrl('img/recipes/Lockdown.svg')}]\nPros:\n * Highest security rating\n * Elegant and powerful\n\nCons:\n * Rust skills required\n * No remote resources\n\n## Description The Lockdown recipe is a minimal usage of the [Bridge\npattern](./bridge.md), which only allows interaction between Rust and the Window\nvia expiring JS Promise Closures that are injected into the Window by Rust and\nnulled as part of the callback. ## Diagram import Mermaid, { colors } from\n'@theme/Mermaid' F G-.->B B-->G subgraph WEBVIEW G-->F end subgraph RUST A-->B\nA==>H end A[Binary] B[API:Event] F[Window] G((Promise Closure)) H{Bootstrap}\nstyle RUST\nfill:${colors.orange.light},stroke:${colors.orange.dark},stroke-width:4px style\nWEBVIEW fill:${colors.blue.light},stroke:${colors.blue.dark},stroke-width:4px`}\n/> ## Configuration Here's what you need to add to your tauri.conf.json file:\n```json \"tauri\": { \"allowlist\": {} // all API endpoints are default false } ```","url":"https://tauri.studio/docs/architecture/recipes/lockdown"},{"id":"prose_docs_architecture_recipes_multiwin_md","title":"Multiwin","area":"architecture","section":"recipes","headings":["Description","Diagram","Configuration"],"subHeadings":[],"code":[],"text":"import Alert from '@theme/Alert' import useBaseUrl from '@docusaurus/useBaseUrl'\nimport Rater from '@theme/Rater'\n\nEase of Use Extensibility Performance Security\n\nMultiwin [{useBaseUrl('img/recipes/Multiwin.svg')}]\nPros:\n * Windows can be spawned or destroyed at runtime\n * Separation of concerns\n\nCons:\n * Somewhat complex\n\n## Description The Multiwin recipe will allow you to have multiple windows. ##\nDiagram import Mermaid, { colors } from '@theme/Mermaid' H H==>F H==>G subgraph\nWEBVIEW F end subgraph WINIT G end subgraph RUST A end A[Binary] F[Window]\nG[Window] H{Bootstrap} style WINIT stroke:${colors.blue.dark},stroke-width:4px\nstyle RUST\nfill:${colors.orange.light},stroke:${colors.orange.dark},stroke-width:4px style\nWEBVIEW fill:${colors.blue.light},stroke:${colors.blue.dark},stroke-width:4px`}\n/> ## Configuration Here's what you need to add to your tauri.conf.json file:\n```json \"tauri\": { \"allowlist\": {}, // all API endpoints are default false\n\"windows\": [{ \"title\": \"Window1\", \"label\": \"main\", }, { \"title\": \"Splash\",\n\"label\": \"splashscreen\" }] } ```","url":"https://tauri.studio/docs/architecture/recipes/multiwin"},{"id":"prose_docs_building_app_size_md","title":"Reducing the App Size","area":"building","section":"building","headings":["Checklist","1","2","3","4","5","6","7","8"],"subHeadings":["You can","Think twice before adding a dependency","Why","How","Why","How","Why","How","Why","How","Why","How","Why","How","Unstable Rust Compression Features","Why","How","Why","How"],"code":["css","json","toml","sh"],"text":"# Reducing the App Size At Tauri, we are working on reducing the environmental\nfootprint of applications by using system resources where available, providing\ncompiled systems that don't need runtime evaluation, and offering guides so that\nengineers can go even smaller without sacrificing on performance or security.\nThe point is, by saving resources, we are doing our part to help you help us\nsave the planet -- which is the only bottom line that companies in the 21st\nCentury should care about. So if you are interested in learning how to improve\nyour app size and performance, read on, dear friend: ### You can't improve what\nyou can't measure Before you can optimize your app, you need to figure out what\ntakes up space in your app! Here are a couple of tools that can assist you with\nthat: - **`cargo-bloat`** [`cargo-bloat`][cargo-bloat] is a rust utility to\ndetermine what takes the most space in your app. It gives you an excellent,\nsorted overview of the most significant rust functions. - **`cargo-expand`**\n[Macros] make your rust code more concise and easier to read, but they are also\nhidden size traps! Use [`cargo-expand`][cargo-expand] to see what those macros\ngenerate under the hood. - **`rollup-plugin-visualizer`**\n[`rollup-plugin-visualizer`][rollup-plugin-visualizer] generates beautiful (and\ninsightful) graphs from your rollup bundle. Very convenient for figuring out\nwhat JavaScript dependencies contribute to your final bundle size the most. -\n**`rollup-plugin-graph`** You noticed a dependency included in your final\nfrontend bundle, but you are unsure why?\n[`rollup-plugin-graph`][rollup-plugin-graph] generates graphviz compatible\nvisualizations of your entire dependency graph. These are just a couple of tools\nthat you might use. Make sure to check your frontend bundlers plugin list for\nmore! ### Think twice before adding a dependency ## Checklist - [Reducing the\nApp Size](#reducing-the-app-size) - [You can't improve what you can't\nmeasure](#you-cant-improve-what-you-cant-measure) - [Think twice before adding a\ndependency](#think-twice-before-adding-a-dependency) - [Checklist](#checklist) -\n[1. Minify Javascript](#1-minify-javascript) - [Why?](#why) - [How?](#how) - [2.\nOptimize Dependencies](#2-optimize-dependencies) - [Why?](#why-1) -\n[How?](#how-1) - [3. Optimize Images](#3-optimize-images) - [Why?](#why-2) -\n[How?](#how-2) - [4. Remove Unnecessary Custom\nFonts](#4-remove-unnecessary-custom-fonts) - [Why?](#why-3) - [How?](#how-3) -\n[5. Allowlist Config](#5-allowlist-config) - [Why?](#why-4) - [How?](#how-4) -\n[6. Rust Build-time Optimizations](#6-rust-build-time-optimizations) -\n[Why?](#why-5) - [How?](#how-5) - [Unstable Rust Compression\nFeatures](#unstable-rust-compression-features) - [7. Stripping](#7-stripping) -\n[Why?](#why-6) - [How?](#how-6) - [8. UPX](#8-upx) - [Why?](#why-7) -\n[How?](#how-7) - [Usage on macOS](#usage-on-macos) ## 1. Minify Javascript ###\nWhy? JavaScript makes up a large portion of a typical Tauri app, so it's\nimportant to make the JavaScript as lightweight as possible. ### How? You can\nchoose among a plethora of JavaScript bundlers; popular choices are [Vite],\n[webpack], and [rollup]. All of them can produce minified JavaScript if\nconfigured correctly, so please consult your bundler documentation for specific\noptions. Generally speaking; however, you should make sure to: - **Enable tree\nshaking** This option removes unused JavaScript from your bundle. All popular\nbundlers enable this by default. - **Enable minification** Minification removes\nunnecessary whitespace, shortens variable names, and applies other\noptimizations. Most bundlers enable this by default; a notable exception is\n[rollup], where you need plugins like [rollup-plugin-terser] or\n[rollup-plugin-uglify]. :::note You can use minifiers like [terser] and\n[esbuild] as standalone tools. ::: - **Disable source maps** Source maps provide\na pleasant developer experience when working with languages that compile to\nJavaScript, such as [TypeScript]. As source maps tend to be quite large, you\nmust disable them when building for production. They have no benefit to your\nend-user, so it's effectively dead weight. ## 2. Optimize Dependencies Many\npopular libraries have smaller and faster alternatives that you can choose\ninstead. ### Why? Most libraries you use depend on many libraries themselves, so\na library that looks inconspicuous at first glance might add **several\nmegabytes** worth of code to your app. ### How? You can use [Bundlephobia] to\nfind the cost of JavaScript dependencies. Inspecting the cost of rust\ndependencies is generally harder since the compiler does many optimizations. If\nyou find a library that seems excessively large, google around, chances are\nsomeone else already had the same thought and created an alternative. A good\nexample is [Moment.js] and it's [Many alternatives][you-dont-need-momentjs]. But\nkeep in mind: **The best dependency is no dependency**, meaning that you should\nalways prefer language builtins over 3rd party packages. ## 3. Optimize Images\n### Why? According to the [Http Archive], images are the [biggest contributor to\nwebsite weight][http archive report, image bytes]. So if your app includes have\nbackground images or icons, make sure to optimize them! ### How? You can choose\nbetween a variety of manual options ([GIMP], [Photoshop], [Squoosh]) or plugins\nfor your favorite frontend build tools ([vite-imagetools],\n[vite-plugin-imagemin], [image-minimizer-webpack-plugin]). :::caution The\n`imagemin` library most of the plugins use is [officially unmaintained][imagemin\nis unmaintained]. ::: - **Use modern image formats** Formats such as `webp` or\n`avif` offer size reductions of **up to 95%** compared to jpeg while maintaining\nexcellent visual accuracy. You can use tools such as [Squoosh] to try different\nformats on your images. - **Size images accordingly** No one appreciates you\nshipping the 6K raw image with your app, so make sure to size your image\naccordingly. Images that appear large on-screen should be sized larger than\nimages that take up less screen space. - **Don't use Responsive Images** In a\nWeb Environment, you are supposed to use [Responsive Images] to load the correct\nimage size for each user dynamically. You are not building a simple website,\nthough: All your images are already downloaded. So using Responsive Images only\nbloat your app with redundant copies. - **Remove Metadata** Images that were\ntaken straight from a camera or stock photo side often include metadata about\nthe Camera and Lens model or Photographer. Not only are those wasted bytes, but\nmetadata properties can also hold potentially sensitive information such as the\ntime, day, and location of the photo. ## 4. Remove Unnecessary Custom Fonts\nConsider not shipping custom fonts with your app and relying on system fonts\ninstead. If you must ship custom fonts, make sure they are in modern, optimized\nformats such as `woff2`. ### Why? Fonts can be pretty big, so using the fonts\nalready included in the Operating System reduces the footprint of your app. It\nalso avoids FOUT (Flash of Unstyled Text) and makes your app feel more \"native\"\nsince it uses the same font as all other apps. If you must include custom fonts,\nmake sure you include them in modern formats such as `woff2` as those tend to be\nway smaller than legacy formats. ### How? Use so-called **\"System Font Stacks\"**\nin your CSS. There are a number of variations, but here are 3 basic ones to get\nyou started: - **Sans-serif** ```css font-family: -apple-system,\nBlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif, 'Apple Color\nEmoji', 'Segoe UI Emoji'; ``` - **Serif** ```css font-family: Iowan Old Style,\nApple Garamond, Baskerville, Times New Roman, Droid Serif, Times, Source Serif\nPro, serif, Apple Color Emoji, Segoe UI Emoji, Segoe UI Symbol; ``` -\n**Monospace** ```css font-family: ui-monospace, SFMono-Regular, SF Mono, Menlo,\nConsolas, Liberation Mono, monospace; ``` ## 5. Allowlist Config You can reduce\nthe size of your app by only enabling the Tauri API features you need in the\n`allowlist` config. ### Why? The `allowlist` config determines what API features\nto enable; disabled features will **not be compiled into your app**. This is an\neasy way of shedding some extra weight. ### How? An example from a typical\n`tauri.conf.json`: ```json { \"tauri\": { \"allowlist\": { \"all\": false, \"fs\": {\n\"writeFile\": true }, \"shell\": { \"execute\": true }, \"dialog\": { \"save\": true } }\n} } ``` ## 6. Rust Build-time Optimizations Configure your cargo project to take\nadvantage of rusts size optimization features. [Why is a rust executable large\n?] provides an excellent explanation on why this matters and an in-depth\nwalkthrough. At the same time, [Minimizing Rust Binary Size] is more up-to-date\nand has a couple of extra recommendations. ### Why? Rust is notorious for\nproducing large binaries, but you can instruct the compiler to optimize the\nfinal executable's size. ### How? Cargo exposes several options that determine\nhow the compiler generates your binary. The \"recommended\" options for Tauri apps\nare these: ```toml [profile.release] panic = \"abort\" # Strip expensive panic\nclean-up logic codegen-units = 1 # Compile crates one after another so the\ncompiler can optimize better lto = true # Enables link to optimizations\nopt-level = \"s\" # Optimize for binary size ``` :::note There is also `opt-level\n= \"z\"` available to reduce the resulting binary size. `\"s\"` and `\"z\"` can\nsometimes be smaller than the other, so test it with your application! We've\nseen smaller binary sizes from `\"s\"` for Tauri example applications, but\nreal-world applications can always differ. ::: For a detailed explanation of\neach option and a bunch more, refer to the [Cargo books Profiles section][cargo\nprofiles]. ### Unstable Rust Compression Features :::caution The following\nsuggestions are all unstable features and require a nightly toolchain. See the\n[Unstable Features][cargo unstable features] documentation for more information\non what this involves. ::: The following methods involve using unstable compiler\nfeatures and require the rust nightly toolchain. If you don't have the nightly\ntoolchain + `rust-src` nightly component added, try the following: ```sh $\nrustup toolchain install nightly $ rustup component add rust-src --toolchain\nnightly ``` The Rust Standard Library comes precompiled. This means rust is\nfaster to install, but also that the compiler can't optimize the Standard\nLibrary. You can apply the optimization options for the rest of your binary +\ndependencies to the std with an unstable flag. This flag requires specifying\nyour target, so know the target triple you are targeting. ```sh $ cargo +nightly\nbuild --release -Z build-std --target x86_64-unknown-linux-gnu ``` If you are\nusing `panic = \"abort\"` in your release profile optimizations, you need to make\nsure the `panic_abort` crate is compiled with std. Additionally, an extra std\nfeature can further reduce the binary size. The following applies both: ```sh $\ncargo +nightly build --release -Z build-std=std,panic_abort -Z\nbuild-std-features=panic_immediate_abort --target x86_64-unknown-linux-gnu ```\nSee the unstable documentation for more details about [`-Z build-std`][cargo\nbuild-std] and [`-Z build-std-features`][cargo build-std-features]. ## 7.\nStripping Use strip utilities to remove debug symbols from your compiled app.\n### Why? Your compiled app includes so-called \"Debug Symbols\" that include\nfunction and variable names. Your end-users will probably not care about Debug\nSymbols, so this is a pretty surefire way to save some bytes! ### How? The\neasiest way is to use the famous `strip` utility to remove this debugging\ninformation. ```sh $ strip target/release/my_application ``` See your local\n`strip` manpage for more information and flags that can be used to specify what\ninformation gets stripped out from the binary. ## 8. UPX UPX, **Ultimate Packer\nfor eXecutables**, is a dinosaur amongst the binary packers. This 23-year old,\nwell-maintained piece of kit is GPL-v2 licensed with a pretty liberal usage\ndeclaration. Our understanding of the licensing is that you can use it for any\npurposes (commercial or otherwise) without needing to change your license unless\nyou modify the source code of UPX. ### Why? Maybe your target audience has very\nslow internet, or your app needs to fit on a tiny USB stick, and all the above\nsteps haven't resulted in the savings you need. Fear not, as we have one last\ntrick up our sleeves: [UPX] compresses your binary and creates a self-extracting\nexecutable that decompresses itself at runtime. ### How? :::caution You should\nknow that this technique might flag your binary as a virus on Windows and macOS\n- so use at your own discretion, and as always, validate with [Frida] and do\nreal distribution testing! ::: #### Usage on macOS ```sh $ brew install upx $\nyarn tauri build $ upx --ultra-brute\nsrc-tauri/target/release/bundle/macos/app.app/Contents/macOS/app Ultimate Packer\nfor eXecutables Copyright (C) 1996 - 2018 UPX 3.95 Markus Oberhumer, Laszlo\nMolnar & John Reiser Aug 26th 2018 File size Ratio Format Name\n-------------------- ------ ----------- ----------- 963140 -> 274448 28.50%\nmacho/amd64 app ``` [cargo-bloat]: https://github.com/RazrFalcon/cargo-bloat\n[Macros]: https://doc.rust-lang.org/book/ch19-06-macros.html [cargo-expand]:\nhttps://github.com/dtolnay/cargo-expand [rollup-plugin-visualizer]:\nhttps://github.com/btd/rollup-plugin-visualizer [rollup-plugin-graph]:\nhttps://github.com/ondras/rollup-plugin-graph [vite]: https://vitejs.dev\n[webpack]: https://webpack.js.org [rollup]: https://rollupjs.org/guide/en/\n[rollup-plugin-terser]: https://github.com/TrySound/rollup-plugin-terser\n[rollup-plugin-uglify]: https://github.com/TrySound/rollup-plugin-uglify\n[terser]: https://terser.org [esbuild]: https://esbuild.github.io [typescript]:\nhttps://www.typescriptlang.org [moment.js]: https://momentjs.com\n[you-dont-need-momentjs]:\nhttps://github.com/you-dont-need/You-Dont-Need-Momentjs [http archive]:\nhttps://httparchive.org [http archive report, image bytes]:\nhttps://httparchive.org/reports/page-weight#bytesImg [imagemin is unmaintained]:\nhttps://github.com/imagemin/imagemin/issues/385 [gimp]: https://www.gimp.org\n[photoshop]: https://www.adobe.com/de/products/photoshop.html [vite-imagetools]:\nhttps://github.com/JonasKruckenberg/imagetools [vite-plugin-imagemin]:\nhttps://github.com/vbenjs/vite-plugin-imagemin [image-minimizer-webpack-plugin]:\nhttps://github.com/webpack-contrib/image-minimizer-webpack-plugin [squoosh]:\nhttps://squoosh.app [responsive images]:\nhttps://developer.mozilla.org/en-US/docs/Learn/HTML/Multimedia_and_embedding/Responsive_images\n[why is a rust executable large ?]:\nhttps://lifthrasiir.github.io/rustlog/why-is-a-rust-executable-large.html\n[minimizing rust binary size]: https://github.com/johnthagen/min-sized-rust\n[cargo unstable features]:\nhttps://doc.rust-lang.org/cargo/reference/unstable.html#unstable-features [cargo\nprofiles]: https://doc.rust-lang.org/cargo/reference/profiles.html [cargo\nbuild-std]: https://doc.rust-lang.org/cargo/reference/unstable.html#build-std\n[cargo build-std-features]:\nhttps://doc.rust-lang.org/cargo/reference/unstable.html#build-std-features\n[Bundlephobia]: https://bundlephobia.com [Frida]: https://frida.re/docs/home/\n[UPX]: https://github.com/upx/upx","url":"https://tauri.studio/docs/building/app-size"},{"id":"prose_docs_building_cross_platform_md","title":"Cross","area":"building","section":"building","headings":[],"subHeadings":[],"code":[],"text":"# Cross-Platform Compilation How to use GH Action for Building: a glance at\nTauri Action.","url":"https://tauri.studio/docs/building/cross-platform"},{"id":"prose_docs_building_debian_md","title":"Debian packages","area":"building","section":"building","headings":["Bootstrapper","Custom files"],"subHeadings":[],"code":["json"],"text":"# Debian packages Tauri allows your app to be packaged as a `.deb` (Debian\npackage) file. ## Bootstrapper Instead of launching the app directly, you can\nconfigure the bundled app to run a script that tries to expose the environment\nvariables to the app; without that, you'll have trouble using system programs\nbecause the `PATH` environment variable isn't correct. Enable it with the\n[`useBootstrapper`] config. ## Custom files To include custom files to the\ndebian package, you can configure a mapping on `tauri.conf.json > tauri > bundle\n> deb > files` as follows: ```json { \"tauri\": { \"bundle\": { \"deb\": { \"files\": {\n\"/usr/lib/README.md\": \"../README.md\", // copies the README.md file to\n/usr/lib/README.md \"usr/lib/assets\": \"../public/\" // copies the entire public\ndirectory to /usr/lib/assets } } } } } ``` ::note Each `files` object key is the\npath on the Debian package, and the value is a path to a file or directory\nrelative to the `tauri.conf.json` file. ::: [`useBootstrapper`]:\n/docs/api/config#tauri.bundle.deb.useBootstrapper","url":"https://tauri.studio/docs/building/debian"},{"id":"prose_docs_building_introduction_md","title":"Introduction","area":"building","section":"building","headings":[],"subHeadings":[],"code":[],"text":"# Introduction The Tauri Bundler is a Rust harness to compile your binary,\npackage assets, and prepare a final bundle. It will detect your operating system\nand build a bundle accordingly. It currently supports: - Linux: .deb, .appimage\n- macOS: .app, .dmg - Windows: .exe, .msi","url":"https://tauri.studio/docs/building/introduction"},{"id":"prose_docs_building_sidecar_md","title":"Sidecar ","area":"building","section":"building","headings":["Running the sidecar binary on JavaScript","Running the sidecar binary on Rust","Using Node"],"subHeadings":[],"code":["json","bash","javascript","rust"],"text":"# Sidecar (Embedding External Binaries) You may need to embed depending binaries\nto make your application work or prevent users from installing additional\ndependencies (e.g., Node.js or Python). To bundle the binaries of your choice,\nyou can add the `externalBin` property to the `tauri > bundle` object in your\n`tauri.conf.json`. See more about tauri.conf.json configuration\n[here][tauri.bundle]. `externalBin` expects a list of strings targeting binaries\neither with absolute or relative paths. Here is a sample to illustrate the\nconfiguration. This is not a complete `tauri.conf.json` file: ```json { \"tauri\":\n{ \"bundle\": { \"externalBin\": [\"/absolute/path/to/app\",\n\"relative/path/to/binary\", \"bin/python\"] } } } ``` A binary with the same name\nand a `-$TARGET_TRIPLE` suffix must exist on the specified path. For instance,\n`\"externalBin\": [\"bin/python\"]` requires a\n`src-tauri/bin/python-x86_64-unknown-linux-gnu` executable on Linux. You can\nfind the current platform's target triple running the following command: ```bash\nrustc -Vv | grep host | cut -f2 -d' ' ``` Here's a Node.js script to append the\ntarget triple to a binary: ```javascript const execa = require('execa') const fs\n= require('fs') let extension = '' if (process.platform === 'win32') { extension\n= '.exe' } async function main() { const rustInfo = (await execa('rustc',\n['-vV'])).stdout const targetTriple = /host: (\\S+)/g.exec(rustInfo)[1] if\n(!targetTriple) { console.error('Failed to determine platform target triple') }\nfs.renameSync( `src-tauri/binaries/app${extension}`,\n`src-tauri/binaries/app-${targetTriple}${extension}` ) } main().catch((e) => {\nthrow e }) ``` ## Running the sidecar binary on JavaScript On the JavaScript\ncode, import the `Command` class on the `shell` module and use the `sidecar`\nstatic method: ```javascript import { Command } from '@tauri-apps/api/shell' //\nalternatively, use `window.__TAURI__.shell.Command` // `my-sidecar` is the value\nspecified on `tauri.conf.json > tauri > bundle > externalBin` const command =\nCommand.sidecar('my-sidecar') const output = await command.execute() ``` ##\nRunning the sidecar binary on Rust On the Rust code, import the `Command` struct\nfrom the `tauri::api::process` module: ```rust let (mut rx, mut child) =\nCommand::new_sidecar(\"my-sidecar\") .expect(\"failed to create `my-sidecar` binary\ncommand\") .spawn() .expect(\"Failed to spawn sidecar\");\ntauri::async_runtime::spawn(async move { // read events such as stdout while let\nSome(event) = rx.recv().await { if let CommandEvent::Stdout(line) = event {\nwindow .emit(\"message\", Some(format!(\"'{}'\", line))) .expect(\"failed to emit\nevent\"); // write to stdin child.write(\"message from\nRust\\n\".as_bytes()).unwrap(); } } }); ``` ## Using Node.js on a sidecar The\nTauri [sidecar example] demonstrates how to use the sidecar API to run a Node.js\napplication on Tauri. It compiles the Node.js code using [pkg] and uses the\nscripts above to run it. [tauri.bundle]: /docs/api/config#tauri.bundle [sidecar\nexample]: https://github.com/tauri-apps/tauri/tree/dev/examples/sidecar [pkg]:\nhttps://github.com/vercel/pkg","url":"https://tauri.studio/docs/building/sidecar"},{"id":"prose_docs_community_ci_cd_md","title":"CI","area":"community","section":"community","headings":["Continuous Integration","Continuous Deployment"],"subHeadings":["Introduction to immutable checksum","Next Steps"],"code":["yml"],"text":"# CI/CD ## Continuous Integration Github Actions has two triggers we use\nheavily: `push` and `pull_request`. Every commit that is made to the repo is a\n`push`. When you open a pull request from a branch (call it `great_feature`) to\nanother branch (our working branch, `dev`), each commit to `great_feature` would\npossibly trigger both of these events. We can use a filter to focus on the\nevents we care about, however. In our workflows, we only PR (pull request) the\n`dev` and `master` branches. This means that if we filter to only the `dev` and\n`master` branches on commit, we will only run that workflow when we _merge_ a\nPR. A merged PR typically only occurs once a day or less, so this is a good fit\nfor the longer running tests, e.g., the smoke tests in our case. Below is how\nthat might look. Unit tests: ```yml # these run fast so we can have them run on\nany commit name: unit tests on: pull_request: push: branches: - dev - master ```\nSmoke tests: ```yml # these run slower so we run only on merges to dev or master\nbranch name: smoke tests on: push: branches: - dev - master ``` Tauri operates\noff the `dev` branch as default, and merges to `master` for release. With these\nGithub Actions set up, we will run the unit tests on every commit to an open PR\n(see `pull_request`). When that PR is merged into `dev`, we will run both the\nunit tests and the smoke tests. ## Continuous Deployment ### Introduction to\nimmutable checksum It is not only possible, but trivial to modify release notes\nand artifacts after it has been published on Github. While there are very valid\nreasons for doing this, it is not exactly a totally trustworthy method - i.e.\nyou have no guarantee that what you are reading is really reflective of the\nunderlying truth or the tarballs. It is technically possible to change downloads\nover the wire or in the box or change checksums in targeted attacks. What we are\nseeking to accomplish is a best case scenario where: 1. Human error is reduced\nto a minimum, but humans are still integral in the actual release 2. Machine\nbuilt assets, changelogs and attached security audits are verifiable with\nchecksums that are published in an immutable, globally available store. To this\nend we fashioned a workflow shown below. As it stands now, we have #3 through #6\nimplemented. We manually do #2 which then feeds into #3 and kicks off the rest\nof the automatic workflow. 1. a human pushes to dev through a pull request (can\nhappen any number of times) - pull request includes a changeset file describing\nthe change and required version bump 2. a pull request is created (or updated)\nto include the change and version bump - this pull request stays open and will\nbe force pushed until it gets merged (and published) - increase the version\nnumber based on changesets - delete all changeset files 3. a codeowner merges\nthe publish PR to dev (no direct push permissible for anyone) - all tests (unit,\ne2e, smoke tests) are run on the PR - failures prevent the publish so they must\npass before merge 4. merge to dev triggers release sequence - changes are\nsquashed and a PR is opened against master 5. when PR to master is merged... -\nvulnerability audit (crates and yarn) and output saved - checksums and metadata\nand output saved - packages are published on npm/cargo, tarball/zip created -\nrelease is created for each package that had updates (if version isn't changed,\nbuild skips the publish steps) - output from audit/checksums is piped into the\nrelease body - tarball / zip attached to release - async process to publish to\nIOTA tangle (feeless) via release tag [note: still have things to resolve here]\n6. release is complete - master has updated code and tagged - GitHub release has\ntarballs, checksums, and changelog (may have multiple releases if more than one\npackage published) [note: is part of step 2 and is not yet implemented] ### Next\nSteps Next steps may include transferring and publishing the built assets to\nadditional places: 1. Tauri's private verdaccio 2. IPFS 3. PureOS Gitlab 4.\nGitHub Packages We can also do some interesting things like signing our\nreleases, including a hash in the release and/or even publishing this\ninformation on a blockchain that it can be easily verified. Publishing on the\nblockchain is another avenue to increase the confidence that what is seen on\nGitHub matches what you have downloaded. The IOTA foundation created a Github\nAction which will publish a release to their blockchain. This has shown promise,\nbut he gave a couple errors to tackle still.","url":"https://tauri.studio/docs/community/ci-cd"},{"id":"prose_docs_community_contributor_guide_md","title":"Contributor Guide","area":"community","section":"community","headings":["Contribution Flow","Hands"],"subHeadings":["A Note About Contributions to the Rust Libraries"],"code":["sh","json","ini"],"text":"# Contributor Guide todo: make this friendlier and more complete Tauri is a\npolyglot system that uses: - git - Node.js - Rust - GitHub actions It can be\ndeveloped on macOS, Linux, and Windows. ## Contribution Flow 1. File an Issue 2.\nFork the Repository 3. Make Your Changes 4. Make a PR ### A Note About\nContributions to the Rust Libraries When contributing to the Rust libraries\n`tauri`, `tauri-api`, and `tauri-updater`; you want to set up an environment for\nRLS (the Rust Language Server). In the Tauri root directory, there is a\n`.scripts` folder that contains a set of scripts to automate adding a couple\ntemporary environment variables to your shell/terminal. These environment\nvariables point to directories in the test fixture, which prevents RLS from\ncrashing on compile-time. This is a necessary step for setting up a development\nenvironment for Tauri's Rust libraries. ##### _Example Instructions_ 1. Navigate\nto the Tauri Root directory. 2. Execute a script based on your Operating System\nfrom this folder: `.scripts/init_env.bat` for Windows Cmd,\n`.scripts/init_env.ps1` for Windows Powershell, `. .scripts/init_env.sh` for\nLinux/macOS bash (note the first `.` in this command). 3. Open your text\neditor/IDE from this shell/terminal. ## Hands-On Example Let's make a new\nexample. That's a great way to learn. We assume you are on a nixy type of\nenvironment like Linux or macOS and have all of your development dependencies\nlike rust and node already sorted out. ```sh git clone\ngit@github.com:tauri-apps/tauri.git cd tauri/cli/tauri.js yarn mkdir\n../../examples/vanillajs && cd \"$_\" ``` ```json \"tauri:source\": \"node\n../../../cli/tauri.js/bin/tauri\", ``` ```ini [dependencies.tauri] path =\n\"../../../../core/tauri\" features = [ \"all-api\" ] ```","url":"https://tauri.studio/docs/community/contributor-guide"},{"id":"prose_docs_debugging_debugging_md","title":"Debugging","area":"debugging","section":"debugging","headings":["Rust Console","WebView JS Console","Create a Debug Build","Run Your App From the Terminal"],"subHeadings":[],"code":["rust","sh",null],"text":"import Command from '@theme/Command' # Debugging With all the moving pieces in\nTauri, you may run into a problem that requires debugging. There are many\nlocations where error details are printed, and Tauri includes some tools to make\nthe debugging process more straightforward. ## Rust Console The first place to\nlook for errors is in the Rust Console. This is in the terminal where you ran,\ne.g., Tauri dev. You can use the following code to print something to that\nconsole from within a Rust file: ```rust println!(\"Message from Rust: {}\", msg);\n``` Sometimes you may have an error in your Rust code, and the Rust compiler can\ngive you lots of information. If, for example, `tauri dev` crashes, you can\nrerun it like this on Linux and macOS: ```sh RUST_DEBUG=1 tauri dev ``` or like\nthis on MS Windows: ```sh set RUST_DEBUG=1 tauri dev ``` This command gives you\na granular stack trace. Generally speaking, the Rust compiler helps you by\ngiving you detailed information about the issue, such as: ``` error[E0425]:\ncannot find value `sun` in this scope --> src/main.rs:11:5 | 11 | sun +=\ni.to_string().parse::().unwrap(); | ^^^ help: a local variable with a similar\nname exists: `sum` error: aborting due to previous error For more information\nabout this error, try `rustc --explain E0425`. ``` ## WebView JS Console\nRight-click in the WebView, and choose `Inspect Element`. This opens up a\nweb-inspector similar to the Chrome or Firefox dev tools you are used to. ##\nCreate a Debug Build There are cases where you might need to inspect the JS\nconsole in the final bundle, so Tauri provides a simple command to create a\ndebugging bundle: Like the normal build and dev processes, building takes some\ntime the first time you run this command but is significantly faster on\nsubsequent runs. The final bundled app has the development console enabled and\nis placed in `src-tauri/target/debug/bundle`. ## Run Your App From the Terminal\nYou can also run a built app from the terminal, giving you the Rust compiler\nnotes (in case of errors) or your `println` messages. Just find the file\n`src-tauri/target/(release|debug)/[app name]` and either double click it (but be\nwarned, the terminal closes on errors) or just run it in directly in your\nconsole.","url":"https://tauri.studio/docs/debugging/debugging"},{"id":"prose_docs_development_development_cycle_md","title":"Development Cycle","area":"development","section":"development","headings":[],"subHeadings":["1","2"],"code":[],"text":"import Command from '@theme/Command' # Development Cycle ### 1. Start Your Dev\nserver Now that you have everything set up, you should start your application\ndevelopment server provided by your UI framework or bundler (assuming you're\nusing one, of course). :::note Every framework has its development tooling. It\nis outside of the scope of this document to treat them all or keep them up to\ndate. ::: ### 2. Start Tauri Development Window The first time you run this\ncommand, the Rust package manager takes several minutes to download and build\nall the required packages. Since they are cached, subsequent builds are much\nfaster, as only your code needs rebuilding. Once Rust has finished building, the\nwebview opens, displaying your web app. You can make changes to your web app,\nand if your tooling enables it, the webview should update automatically, just\nlike a browser. When you make changes to your Rust files, they are rebuilt\nautomatically, and your app automatically restarts. :::info About Cargo.toml and\nSource Control In your project repository, you SHOULD commit the\n\"src-tauri/Cargo.lock\" along with the \"src-tauri/Cargo.toml\" to git because\nCargo uses the lockfile to provide deterministic builds. As a result, it is\nrecommended that all applications check in their Cargo.lock. You SHOULD NOT\ncommit the \"src-tauri/target\" folder or any of its contents. :::","url":"https://tauri.studio/docs/development/development-cycle"},{"id":"prose_docs_development_security_md","title":"Security","area":"development","section":"development","headings":["Tauri Features to keep you Safer"],"subHeadings":["Secure content loading","Isolation Pattern","Tauri API"],"code":["typescript","rust","json"],"text":"# Security Whether you like it or not, today's applications live in operating\nsystems that can be -- and regularly are -- compromised by any number of\nattacks. When your insecure application is a gateway for such lateral movement\ninto the operating system, you are contributing to the tools that professional\nhackers have at their disposal. Don't be a tool. This is why we have taken every\nopportunity to help you secure your application, prevent undesired access to\nsystem level interfaces, and manufacture bullet-proof applications. Your users\nassume you are following best practices. We make that easy, but you should still\nread up on it below. ## Security Is A Community Responsibility (adapted from\n[Electron][security-is-everyones-responsibility]) It is important to remember\nthat the security of your Tauri application is the result of the overall\nsecurity of Tauri itself, all Rust and NPM dependencies, your code, and the\ndevices that run the final application. The Tauri Team does its best to do its\npart, the security community does its part, and you too would do well to follow\na few important best practices: - **Keep your application up-to-date with the\nlatest Tauri release.** When releasing your app into the wild, you are also\nshipping a bundle that has Tauri in it. Vulnerabilities affecting Tauri may\nimpact the security of your application. By updating Tauri to the latest\nversion, you ensure that critical vulnerabilities are already patched and cannot\nbe exploited in your application. Also be sure to keep your compiler (rustc) and\ntranspilers (nodejs) up to date, because there are often security issues that\nare resolved. - **Evaluate your dependencies.** While NPM and Crates.io provide\nmany convenient packages, it is your responsibility to choose trustworthy\n3rd-party libraries - or rewrite them in Rust. If you do use outdated libraries\naffected by known vulnerabilities or are unmaintained, your application security\nand good-night's sleep could be in jeopardy. Use tooling like `npm audit` and\n`cargo audit` to automate this process and lean on the security community's\nimportant work. - **Adopt more secure coding practices.** The first line of\ndefense for your application is your own code. Although Tauri can protect you\nfrom common web vulnerabilities, such as Cross-Site Scripting based Remote Code\nExecution, improper configurations can have a security impact. Even if this were\nnot the case, it is highly recommended to adopt secure software development best\npractices and perform security testing. We detail what this means in the next\nsection. - **Educate your Users.** True security really means that unexpected\nbehaviour cannot happen. So in a sense, being more secure means having the peace\nof mind in knowing that ONLY those things that you want to happen can happen. In\nthe real world, though, this is a utopian \"dream\". However, by removing as many\nvectors as possible and building on a solid foundation, your choice for Tauri is\na signal to your users that you really care about them, their safety, and their\ndevices. ## Threat Models Tauri applications are composed of many pieces at\ndifferent points of the lifecycle. Here we describe classical threats and what\nyou SHOULD do about them. - **Upstream Threats.** Tauri is a direct dependency\nof your project, and we maintain strict authorial control of commits, reviews,\npull-requests, and releases. We do our best to maintain up-to-date dependencies\nand take action to either update or fork&fix. Other projects may not be so well\nmaintained, and may not even have ever been audited. Please consider their\nhealth when integrating them, because otherwise you may have adopted\narchitectural debt without even knowing it. - **Development Threats.** We assume\nthat you, the developer, care for your development environment like a shrine of\npurity because it is a thing of beauty. It is on you to make sure that your\noperating system, build toolchains, and associated dependencies are kept up to\ndate. A very real risk all of us face is what is known as \"supply-chain\nattacks\", which are usually considered to be attacks on direct dependencies of\nyour project. However, there is a growing class of attacks in the wild that\ndirectly target development machines, and you would be well-off to address these\nhead-on. One practice that we highly recommend, even if it is a bit more time\nintensive, is to only ever consume critical dependencies from git using hash\nrevisions at best or named tags as second best. This holds true for Rust as well\nas the Node ecosystem. Also, consider requiring all contributors to sign their\ncommits and protect GIT branches and pipelines. - **Buildtime Threats.** Modern\norganisations use CI/CD to manufacture binary artifacts. At Tauri, we even\nprovide a Github Workflow for building on multiple platforms. If you create your\nown CI/CD and depend on third-party tooling, be wary of actions whose versions\nyou have not explicitly pinned. You should sign your binaries for the platform\nyou are shipping to, and while this can be complicated and somewhat costly to\nsetup, end-users expect that your app is verifiably from you. - **Runtime\nThreats** We assume the webview is insecure, which has led Tauri to implement\nseveral protections regarding webview access to system APIs in the context of\nloading untrusted userland content. You can read more in detail below, but using\nthe CSP will lockdown types of communication that the Webview can undertake.\nFurthermore, there is a novel \"Isolation\" pattern that prevents untrusted\ncontent or scripts from accessing the API within the Webview. And please,\nwhatever you do, DO NOT trust the results of cryptography using private keys in\nthe Webview. We gave you Rust for a reason. - **Updater Threats** We have done\nour best to make shipping hot-updates to the app as straightforward and secure\nas possible. However, if you lose control of the manifest server, the build\nserver, or the binary hosting service - all bets are off. If you are building\nyour own system, consult a professional OPS architect and build it properly. ##\nAn unsorted list of big ole DONT'S: - DON'T accept content over http:// or ws://\n- DON'T ship an app with the development console enabled - DON'T forget to [read\nabout XSS][XSS] - DON'T ship any kind of localhost server unless the app needs\nto talk to other devices - DON'T consume JS from a CDN without using an\nintegrity checksum ## Security Researchers Nothing is perfect, attack vectors\nwill be found, and if you have found one - we want to know about it. If you have\na discovery, PLEASE DO NOT FILE A PUBLIC ISSUE OR MAKE A PULL REQUEST. Please\ndiscretely reach out to a member of the team via Discord or Email for\nverification, vulnerability acceptance, and remediation timeline. We believe in\n- and participate in - responsible disclosure. At this time we do not have a\nbug-bounty programme in place, but are actively considering it. ## Tauri\nFeatures to keep you Safer ### Secure content loading Tauri restricts the\n[Content Security Policy (CSP)] of your HTML pages. Local scripts are hashed,\nstyles and external scripts are referenced using a cryptographic nonce, which\nprevents unallowed content from being loaded. The CSP protection is only enabled\nif [`tauri.security.csp`] is set on the Tauri configuration file. You should\nmake it as restricted as possible, only allowing the webview to load assets from\nhosts you trust and preferably own. At compile time, Tauri appends its nonces\nand hashes to the relevant CSP attributes automatically, so you only need to\nworry about what is unique to your application. :::note See [script-src][CSP\nscript-src], [style-src][CSP style-src] and [CSP Sources] for more information\nabout this protection. ::: :::note With the CSP protection enabled, using inline\n`style` attributes it not allowed. ::: :::caution Avoid loading remote content\nsuch as scripts served over a CDN as they introduce an attack vector, but any\nuntrusted file can introduce new and subtle attack vectors. ::: ### Isolation\nPattern The [Isolation Pattern] is a way to inject a secondary, ideally minimal,\nJavaScript application in between your frontend application and Tauri Core. This\nminimal Isolation application can then be used to securely verify and modify IPC\nmessages before they reach Tauri Core. The [Isolation Pattern] guide has more\ninformation. ### Tauri API The [Tauri API] provides functions to access common\nnative functionality such as filesystem access, HTTP requests, system\nnotifications and child processes usage. They provide an easy path to JavaScript\ndevelopers to access the operating system, but they should be used carefully.\n#### Prefer specific commands When accessing a native API, you should prefer\nwriting a dedicated command to implement your business logic instead of writing\neverything on the frontend layer. For instance, see the following frontend API\nusage: ```typescript import { writeFile, Dir } from '@tauri-apps/api/fs' await\nwriteFile({ path: 'report.txt', contents: 'the file content' }, { dir: Dir.App,\n}) ``` If you do not enable the [isolation pattern](#Isolation-pattern), an\nattacker with remote code execution can overwrite the contents of `report.txt`\nsince that API is generic and enabled. If you use a dedicated command, this is\nnot an issue: ```rust #[tauri::command] async fn write_report(app:\ntauri::AppHandle) -> Result<(), String> { let app_dir =\napp.path_resolver().app_dir().expect(\"failed to get app dir\"); let report_path =\napp_dir.join(\"report.txt\"); std::fs::write(&report_path, \"the file content\")\n.map_err(|e| e.to_string()); Ok(()) } fn main() { tauri::Builder::default()\n.invoke_handler(tauri::generate_handler![write_report])\n.run(tauri::generate_context!()) .expect(\"error while running tauri\napplication\"); } ``` ```typescript import { invoke } from\n'@tauri-apps/api/tauri' await invoke('write_report') ``` This example command\nwritten on the backend cannot be exploited. :::note Tauri recommends using the\nwebview as only a user interface layer, keeping important logic on the core\nlayer. ::: #### The allowlist When using the API package, you **must** enable\nonly the interfaces your application is using. See [the allowlist configuration]\nfor options to restrict which APIs are enabled. This not only reduces surface\narea, but also treeshakes out unneeded functionality -- which reduces final\nbinary size. #### API scoping Some API modules provides a configuration to scope\nthe API access and restrict the system resources accessed. ##### Filesystem You\ncan restrict the folders and files that can be accessed when using the `fs`\nmodule. The scope array lists what paths are allowed using glob patterns and\npredefined variables that resolves to a system base directory. :::note The\nvariables are: `$AUDIO`, `$CACHE`, `$CONFIG`, `$DATA`, `$LOCALDATA`, `$DESKTOP`,\n`$DOCUMENT`, `$DOWNLOAD`, `$EXE`, `$FONT`, `$HOME`, `$PICTURE`, `$PUBLIC`,\n`$RUNTIME`, `$TEMPLATE`, `$VIDEO`, `$RESOURCE`, `$APP` and `$CWD`. ::: ```json {\n\"tauri\": { \"allowlist\": { \"fs\": { \"scope\": [\"$APP/db/*\", \"$RESOURCE/check.png\"]\n} } } } ``` ###### Asset protocol You can restrict the folders and files that\ncan be accessed when using the `asset` protocol. The scope array has the same\nsyntax as the `fs` scope array: ```json { \"tauri\": { \"allowlist\": { \"path\": {\n\"all\": true }, \"protocol\": { \"asset\": true, \"assetScope\": ['$APP/assets/*'] } }\n} } ``` ```typescript import { appDir, join } from '@tauri-apps/api/path' import\n{ convertFileSrc } from '@tauri-apps/api/tauri' const appDirPath = await\nappDir() // this path is allowed - is matches $APP/assets/* // you can use this\non tags or window.fetch() calls const allowedPath = convertFileSrc(await\njoin(appDirPath, 'assets', 'tauri.mp4')) // this path is not allowed - it does\nnot match $APP/assets/* const disallowedPath = convertFileSrc(await\njoin(appDirPath, 'tauri.mp4')) ``` ###### HTTP You can restrict the URLs and\npaths that can be accessed when using the `http` module: ```json { \"tauri\": {\n\"allowlist\": { \"http\": { \"scope\": [\"https://api.github.com/repos/tauri-apps/*\"]\n} } } } ``` ```typescript import { fetch } from '@tauri-apps/api/http' // this\npromise is resolved await fetch('https://api.github.com/repos/tauri-apps/tauri')\n// this promise is rejected - the URL is not allowed on the scope await\nfetch('https://api.github.com/repos/electron/electron') ``` ###### Shell To\nprevent unrestricted access to process spawning, Tauri offers a configuration to\ndefine programs and command line arguments that are allowed to be used. While it\ncan make userland ergonomics less simple, is good security hygiene to lock down\nshell commands from spawning other, unexpected commands. ```json { \"tauri\": {\n\"allowlist\": { \"shell\": { \"scope\": [ { \"name\": \"install-dep\", \"cmd\": \"apt-get\",\n\"args\": [ \"install\", { \"validator\": \"(gcc|rustc)$\" } ] } ], // allows using the\n`open` API only using arguments that match this regex // `true` is also a valid\nvalue, which defines the regex as `https?://`. \"open\":\n\"^https://github.com/tauri-apps/\" } } } } ``` ```typescript import { Command,\nopen } from '@tauri-apps/api/shell' // this command is allowed new\nCommand('install-dep', ['install', 'rustc']).spawn() // this command is not\nfound - does not match the `name` value of the scope definition new\nCommand('install-my-dep', ['install', 'rustc']).spawn() // this command is\nrejected - does not match validator regex for the second argument new\nCommand('install-dep', ['install', 'tar']).spawn() // this command is rejected -\nextra argument new Command('install-dep', ['install', 'rustc', '-y']).spawn() //\nthis open() usage is allowed because it matches the `open` regex await\nopen('https://github.com/tauri-apps/tauri') // this open() call is rejected -\ndoes not match validator regex open('https://docs.rs/tauri/latest/tauri') ```\n[security-is-everyones-responsibility]:\nhttps://www.electronjs.org/docs/latest/tutorial/security#security-is-everyones-responsibility\n[XSS]: https://owasp.org/www-community/attacks/xss/ [Content Security Policy\n(CSP)]: https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP\n[`tauri.security.csp`]: /docs/api/config/#tauri.security.csp [CSP script-src]:\nhttps://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/script-src\n[CSP style-src]:\nhttps://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/style-src\n[CSP Sources]:\nhttps://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/Sources#sources\n[Isolation Pattern]: docs/architecture/patterns/isolation [Tauri API]:\nhttps://www.npmjs.com/package/@tauri-apps/api [the allowlist configuration]:\n/docs/api/config/#tauri.allowlist","url":"https://tauri.studio/docs/development/security"},{"id":"prose_docs_development_updating_dependencies_md","title":"Updating Dependencies","area":"development","section":"development","headings":["Automatic updates","Manual updates"],"subHeadings":["Update NPM Packages"],"code":[],"text":"# Updating Dependencies :::caution Please note Especially during the alpha and\nbeta phases, we expect you to keep all Tauri dependencies and toolchains up to\ndate. There is no support for any versions other than latest. ::: ## Automatic\nupdates The Tauri JS CLI has a command to install and update all needed\ndependencies, just run `tauri deps install` or `tauri deps update`. ## Manual\nupdates ### Update NPM Packages If you are using the `tauri` package: ```bash $\nyarn upgrade @tauri-apps/cli @tauri-apps/api --latest $ npm install\n@tauri-apps/cli@latest @tauri-apps/api@latest ``` You can also detect what the\nlatest version of Tauri is on the command line, using: - `npm outdated\n@tauri-apps/cli` - `yarn outdated @tauri-apps/cli` Alternatively, if you are\nusing the `vue-cli-plugin-tauri` approach: ```bash $ yarn upgrade\nvue-cli-plugin-tauri --latest $ npm install vue-cli-plugin-tauri@latest ``` ###\nUpdate Cargo Packages Go to `src-tauri/Cargo.toml` and change `tauri` to `tauri\n= { version = \"%version%\" }` where `%version%` is the version number shown\nabove. (You can just use the `MAJOR.MINOR`) version, like `0.9`. Then do the\nfollowing: ```bash $ cd src-tauri $ cargo update -p tauri ``` You can also run\n`cargo outdated -r tauri` to get direct information about the core library's\nlatest version.","url":"https://tauri.studio/docs/development/updating-dependencies"},{"id":"prose_docs_distribution_linux_md","title":"Linux Application Distribution","area":"distribution","section":"distribution","headings":["Limitations","Debian","AppImage"],"subHeadings":[],"code":["json"],"text":"# Linux Application Distribution Tauri applications for Linux are distributed\neither with a [Debian package] (a file with the `.deb` extension) or as an\n[AppImage] when building using the Tauri CLI. ## Limitations Core libraries such\nas glibc frequently break compatibility with older systems. For this reason, you\nmust build your Tauri application using the oldest base system you intend to\nsupport. A relatively old system such as Ubuntu 18.04 is more suited than Ubuntu\n21.04, as the binary compiled on Ubuntu 21.04 will have a higher requirement of\nthe glibc version, so when running on an older system, you will face a runtime\nerror like `/usr/lib/libc.so.6: version 'GLIBC_2.33' not found`. We recommend\nusing a Docker container or GitHub Actions to build your Tauri application for\nLinux. See the issues [rust-lang/rust#1355] and [rust-lang/rust#57497], in\naddition to the [AppImage guide] for more information. ## Debian The stock\nDebian package generated by the Tauri bundler has everything you need to ship\nyour application to Debian-based Linux distributions, defining your\napplication's icons, generating a Desktop file, and specifying the dependencies\n`libwebkit2gtk-4.0-37` and `libgtk-3-0`, along with `libappindicator3-1` if your\napp uses the system tray. If you need extended control over the Debian package,\nyou can provide a list of folders or files to move to the package. The\nconfiguration object maps the path in the Debian package to the path to the file\non your filesystem, relative to the core binary crate folder (`./src-tauri` by\ndefault). Here's an example configuration: ```json { \"tauri\": { \"bundle\": {\n\"deb\": { \"files\": { \"usr/share/my-app\": \"../assets/\", // copy the entire assets\ndirectory to /usr/share/my-app \"/usr/share/doc/my-app/README.md\":\n\"../README.md\", // copy a single file } } } } } ``` ## AppImage AppImage is a\ndistribution format that does not rely on the system installed packages and\ninstead bundles all dependencies and files needed by the application. For this\nreason, the output file is larger but easier to distribute since it is supported\non many Linux distributions and can be executed without installation, just\nmaking the file executable (`$ chmod a+x MyProject.AppImage`) and running it\n(`./MyProject.AppImage`). AppImages are convenient, simplifying the distribution\nprocess if you cannot make a package targeting the distribution's package\nmanager. Still, you should carefully use it as the file size grows from the\n2-6MBs range to 70+MBs. [Debian Package]: https://wiki.debian.org/Packaging\n[AppImage]: https://appimage.org/ [rust-lang/rust#1355]:\nhttps://github.com/tauri-apps/tauri/issues/1355 [rust-lang/rust#57497]:\nhttps://github.com/rust-lang/rust/issues/57497 [AppImage guide]:\nhttps://docs.appimage.org/reference/best-practices.html#binaries-compiled-on-old-enough-base-system","url":"https://tauri.studio/docs/distribution/linux"},{"id":"prose_docs_distribution_macos_md","title":"macOS Application Distribution","area":"distribution","section":"distribution","headings":["Minimum system version","Binary targets","Application bundle customization","Code signing and notarization"],"subHeadings":[],"code":[],"text":"# macOS Application Distribution Tauri applications for macOS are distributed\neither with an [Application Bundle] (`.app` files) or an Apple Disk Image\n(`.dmg` files). The Tauri CLI automatically bundles your application code in\nthese formats, providing options to codesign and notarize your application. ##\nMinimum system version The minimum version of the operating system required for\na Tauri app to run in macOS is `10.13`. You can change that value on the\n[`tauri.bundle.macOS.minimumSystemVersion`] property. The value is set to the\nInfo.plist key [LSMinimumSystemVersion] and the MACOSX_DEPLOYMENT_TARGET\nenvironment variable. :::note macOS High Sierra (10.13) no longer receives\nsecurity updates from Apple. You should target macOS Catalina (10.15) if\npossible. ::: :::caution Using the `window.print` API requires macOS version\n`11.0+`. ::: ## Binary targets You can compile your application targeting Apple\nSilicon, Intel-based Mac computers, or universal macOS binaries. By default, the\nCLI builds a binary targetting your machine's architecture. If you are using an\nApple Silicon macOS, you can compile Intel and universal binaries using the\n`target` option: - `tauri build --target aarch64-apple-darwin`: targets Apple\nSilicon for your application; - `tauri build --target x86_64-apple-darwin`:\ntargets Intel-based Mac computers; - `tauri build --target\nuniversal-apple-darwin`: targets [universal macOS binaries]. :::caution - Apple\nSilicon binaries only run on Mac computers with Apple Silicon. - Intel-based\nbinaries only run on Intel-based Mac computers and Apple Silicon computers under\nthe Rosetta translation. - Universal macOS binaries run on both architectures.\n::: ## Application bundle customization The Tauri configuration file provides\nthe following options to customize your application bundle: - **Bundle name**:\n[`package.productName`]. - **Bundle version**: [`package.version`]. -\n**Application category**: [`tauri.bundle.category`]. - **Copyright**:\n[`tauri.bundle.copyright`]. - **Bundle icon**: first `.icns` file listed on the\n[`tauri.bundle.icon`] array. - **Minimum system version**:\n[`tauri.bundle.macOS.minimumSystemVersion`]. - **DMG license file**:\n[`tauri.bundle.macOS.license`]. - **[Entitlements.plist file]**:\n[`tauri.bundle.macOS.entitlements`]. - **Exception domain**: an insecure domain\nthat your application can access such as a `localhost` or a remote `http`\ndomain. It is a convenience configuration around `NSAppTransportSecurity >\nNSExceptionDomains` setting `NSExceptionAllowsInsecureHTTPLoads` and\n`NSIncludesSubdomains` to true. See [`tauri.bundle.macOS.exceptionDomain`]. -\n**Bootstrapper**: Instead of launching the app directly, you can configure the\nbundled app to run a script that tries to expose the environment variables to\nthe app; without that, you'll have trouble using system programs because the\n`PATH` environment variable isn't correct. Enable it with\n[`tauri.bundle.macOS.useBootstrapper`]. :::note These options generate the\napplication bundle [Info.plist file]. You can extend the generated file with\nyour own `Info.plist` file stored on the Tauri folder (`src-tauri` by default).\nThe CLI merges both `.plist` files on production, and the core layer embeds it\non the binary on development. ::: ## Code signing and notarization See the [Code\nsigning guide]. [Application Bundle]:\nhttps://developer.apple.com/library/archive/documentation/CoreFoundation/Conceptual/CFBundles/BundleTypes/BundleTypes.html\n[`tauri.bundle.macOS.minimumSystemVersion`]:\n/docs/api/config#tauri.bundle.macOS.minimumSystemVersion\n[LSMinimumSystemVersion]:\nhttps://developer.apple.com/documentation/bundleresources/information_property_list/lsminimumsystemversion\n[universal macOS binaries]:\nhttps://developer.apple.com/documentation/apple-silicon/building-a-universal-macos-binary\n[`package.productName`]: /docs/api/config/#package.productName\n[`package.version`]: /docs/api/config/#package.version\n[`tauri.bundle.category`]: /docs/api/config/#tauri.bundle.category\n[`tauri.bundle.copyright`]: /docs/api/config/#tauri.bundle.copyright\n[`tauri.bundle.icon`]: /docs/api/config/#tauri.bundle.icon\n[`tauri.bundle.macOS.minimumSystemVersion`]:\n/docs/api/config/#tauri.bundle.macOS.minimumSystemVersion\n[`tauri.bundle.macOS.license`]: /docs/api/config/#tauri.bundle.macOS.license\n[Entitlements.plist file]:\nhttps://developer.apple.com/documentation/bundleresources/entitlements\n[`tauri.bundle.macOS.entitlements`]:\n/docs/api/config/#tauri.bundle.macOS.entitlements\n[`tauri.bundle.macOS.exceptionDomain`]:\n/docs/api/config/#tauri.bundle.macOS.exceptionDomain\n[`tauri.bundle.macOS.useBootstrapper`]:\n/docs/api/config#tauri.bundle.deb.useBootstrapper [Info.plist file]:\nhttps://developer.apple.com/library/archive/documentation/General/Reference/InfoPlistKeyReference/Introduction/Introduction.html\n[Code signing guide]: ./sign-macos.md","url":"https://tauri.studio/docs/distribution/macos"},{"id":"prose_docs_distribution_publishing_md","title":"App Publishing","area":"distribution","section":"distribution","headings":[],"subHeadings":["1","2"],"code":[],"text":"import Command from '@theme/Command' # App Publishing ### 1. Build Your Web App\nNow that you are ready to package your project, you need to run your framework's\nor bundler's build command (assuming you're using one, of course). :::note Every\nframework has its publishing tooling. It is outside of the scope of this\ndocument to treat them all or keep them up to date. ::: ### 2. Bundle your\napplication with Tauri This command embeds your web assets into a single binary\nwith your Rust code. The binary itself will be located in\n`src-tauri/target/release/[app name]`, and installers will be located in\n`src-tauri/target/release/bundle/`. Like the `tauri dev` command, the first time\nyou run this, it takes some time to collect the Rust crates and build everything\n- but on subsequent runs, it only needs to rebuild your app's code, which is\nmuch quicker.","url":"https://tauri.studio/docs/distribution/publishing"},{"id":"prose_docs_distribution_sign_macos_md","title":"Code Signing macOS Applications","area":"distribution","section":"distribution","headings":["Requirements","tl","Signing Tauri apps"],"subHeadings":["Creating a signing certificate","Downloading a certificate","Signing the Tauri application","Building the application","Example"],"code":["yml"],"text":"# Code Signing macOS Applications This guide provides information on code\nsigning and notarization for macOS applications. :::note If you are not\nutilizing GitHub Actions to perform builds of OSX DMGs, you will need to ensure\nthe environment variable CI=true exists. For more information refer to\n[tauri-apps/tauri#592]. ::: ## Requirements - Xcode 11 or above. - An Apple\nDeveloper account enrolled in the [Apple Developer Program]. ## tl;dr The Tauri\ncode signing and notarization process is configured through the following\nenvironment variables: - `APPLE_SIGNING_IDENTITY`: the name of the keychain\nentry that contains the signing certificate. - `APPLE_CERTIFICATE`: base64\nstring of the `.p12` certificate, exported from the keychain. Useful if you\ndon't have the certificate on the keychain (e.g., CI machines). -\n`APPLE_CERTIFICATE_PASSWORD`: the password for the `.p12` certificate. -\n`APPLE_ID` and `APPLE_PASSWORD`: your Apple account email and an [app-specific\npassword]. Only required to notarize the app. - `APPLE_API_ISSUER` and\n`APPLE_API_KEY`: authentication with an App Store Connect API key instead of the\nApple ID. Only required if you notarize the app. ## Signing Tauri apps The first\nstep to sign a macOS application is getting a signing certificate from the Apple\nDeveloper Program. ### Creating a signing certificate To create a new signing\ncertificate, you must generate a Certificate Signing Request (CSR) file from\nyour Mac computer. [Create a certificate signing request] describes creating a\nCSR. On your Apple Developer account, navigate to the [Certificates, IDs &\nProfiles page] and click on the `Add` button to open the interface to create a\nnew certificate. Choose the appropriate certificate type (`Apple Distribution`\nto submit apps to the App Store, and `Developer ID Application` to ship apps\noutside the App Store). Upload your CSR, and the certificate will be created.\n:::note Only the Apple Developer `Account Holder` can create *Developer ID\nApplication* certificates. But it can be associated with a different Apple ID by\ncreating a CSR with a different user email address. ::: ### Downloading a\ncertificate On [Certificates, IDs & Profiles page], click on the certificate you\nwant to use and click on the `Download` button. It saves a `.cer` file that\ninstalls the certificate on the keychain once opened. The name of the keychain\nentry represents the `signing identity`, which can also be found by executing `$\nsecurity find-identity -v -p codesigning`. :::note A signing certificate is only\nvalid if associated with your Apple ID. An invalid certificate won't be listed\non the Keychain Access > My Certificates tab or the $ security find-identity -v\n-p codesigning output. ::: ### Signing the Tauri application The signing\nconfiguration is provided to the Tauri bundler via environment variables. You\nneed to configure the certificate to use and an optional authentication\nconfiguration to notarize the application. #### Certificate environment\nvariables - `APPLE_SIGNING_IDENTITY`: this is the `signing identity` we\nhighlighted above. It must be defined to sign apps both locally and on CI\nmachines. Additionally, to simplify the code signing process on CI, Tauri can\ninstall the certificate on the keychain for you if you define the\n`APPLE_CERTIFICATE` and `APPLE_CERTIFICATE_PASSWORD` environment variables. 1.\nOpen the `Keychain Access` app and find your certificate's keychain entry. 2.\nExpand the entry, double click on the key item, and select `Export \"$KEYNAME\"`.\n3. Select the path to save the `.p12` file and define the exported certificate\npassword. 4. Convert the `.p12` file to base64 running the following script on\nthe terminal: `openssl base64 -in /path/to/certificate.p12 -out\ncertificate-base64.txt`. 5. Set the contents of the `certificate-base64.txt`\nfile to the `APPLE_CERTIFICATE` environment variable. 6. Set the certificate\npassword to the `APPLE_CERTIFICATE_PASSWORD` environment variable. ####\nAuthentication environment variables These variables are only required to\nnotarize the application. :::note Notarization is required when using a\nDeveloper ID Application certificate. ::: - `APPLE_ID` and `APPLE_PASSWORD`: to\nauthenticate with your Apple ID, set the `APPLE_ID` to your Apple account email\n(example: `export APPLE_ID=tauri@icloud.com`) and the `APPLE_PASSWORD` to an\n[app-specific password] for the Apple account. - `APPLE_API_ISSUER` and\n`APPLE_API_KEY`: alternatively, you can authenticate using an App Store Connect\nAPI key. Open the App Store Connect's [Users and Access page], select the `Keys`\ntab, click on the `Add` button and select a name and the `Developer` access. The\n`APPLE_API_ISSUER` (`Issuer ID`) is presented above the keys table, and the\n`APPLE_API_KEY` is the value on the `Key ID` column on that table. You also need\nto download the private key, which can only be done once and is only visible\nafter a page reload (the button is shown on the table row for the newly created\nkey). The private key file must be saved on `./private_keys`, `~/private_keys`,\n`~/.private_keys` or `~/.appstoreconnect/private_keys`, as stated on the `$\nxcrun altool --help` command. ### Building the application The Tauri bundler\nautomatically signs and notarizes your application with all these environment\nvariables set when running the `tauri build` command. ### Example The following\nexample uses GitHub Actions to sign an application using the [Tauri action]. We\nfirst define the environment variables we listed above as Secrets on GitHub.\n:::note You can view this guide\n[https://docs.github.com/en/actions/reference/encrypted-secrets] to learn about\nGitHub secrets. ::: Once we have established the GitHub Secrets, we create a\nGitHub publish workflow in `.github/workflows/main.yml`: ```yml name: \"publish\"\non: push: branches: - release jobs: publish-tauri: strategy: fail-fast: false\nmatrix: platform: [macos-latest] runs-on: ${{ matrix.platform }} steps: - uses:\nactions/checkout@v4.2.2
